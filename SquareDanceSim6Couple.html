<!doctype html>
<html>

<head>
    <title>Square dance, 6 couple simulator.</title>
    <style>
        input,
        button {
            margin: 5px;
            font-size: 100%;
        }
    </style>
</head>
<!-- *********************************************************************** -->
<!-- The body section describes the visual layout of the page -->

<!--By default body has a margin=8 which I don't want because I want vh=100 to be the whole screen 
    flex-direction is columns because we are making a column of items. -->

<body style="margin:0; box-sizing:border-box; height:100vh; overflow:hidden; display:flex;"
    onkeydown="onKeyDown(event)">
    <!-- This is the main part of the GUI -->
    <div style="flex-grow:2; display:flex; flex-direction:column; font-size: 1.5rem;">
        <!-- Textbox and buttons -->
        <div style="font-size: 2.5rem">
            <input id=call type=text autofocus tabindex=1 placeholder="Enter Calls" size=10
                onchange="textBoxOnChange(event)">
            <button id=identify tabindex=2 onClick="onCommand('id')"
                title="Identify couples by color (Ctrl-I)&#10Clicking hide on an empty call list will pick new colors.">hide
            </button>
            <button title="Reset the call history (Ctrl-R)" onClick="onCommand('reset')">reset</button>
            <button title="Undo the last call (Ctrl-Z)" tabindex=2 onClick="onCommand('undo')">undo</button>

        </div>

        <div style="overflow-x: hidden;">
            <strong>Message:</strong>
            <span id=resolved
                style="visibility:hidden;display:inline-block;color:red;background-color:rgb(183,181,247); font-size:smaller; vertical-align:middle; margin:0px .6em;text-align:center;">
                Resolved
            </span>
            <span id=message></span>
        </div>
        <!-- The main floor and the prev/saved flow beside them -->
        <div style="flex-grow:1; display:flex;">
            <!-- The Call History column -->
            <div style="background-color:lightgray;min-width:7em; border: 2px solid black; overflow-y:scroll; max-height:calc(90vh - 2.5em);"
                title="Use arrow keys or single click to look at past floor configurations">
                <p>
                    <strong style="display:inline-block; margin:0px 5px">Call History</strong>
                <ol id=callList style="margin-left:1em"></ol>
                </p>
            </div>
            <!-- The main canvas -->
            <div style="display:flex; flex-direction:column; background-color:rgb(252, 221, 236);">
                <canvas id=main width=500 height=500
                    style="margin:auto 5px; background-color:white; border:2px solid red; width:80vmin; height:80vmin;"></canvas>
            </div>
            <!-- The previous and save floor displays -->
            <div style="display:flex; flex-direction:column; background-color:#dfedf5">
                <div style="margin:auto;">
                    <!-- The previous floor display -->
                    <div style="text-align:center; margin:20px 0px 0px 0px; font-size:large; font-weight:bold">Previous
                        Floor
                    </div>
                    <canvas id=prev width=230 height=230
                        style="margin:5px; border:2px solid red; background-color:rgb(236, 236, 236); width:30vmin; height:30vmin"></canvas>
                    <!-- The saved floor display -->
                    <div style="text-align:center;margin:25px 0px 0px 0px;font-size:large;font-weight:bold">Saved Floor
                        <span id=savedCallNum></span>
                    </div>
                    <canvas id=saved width=230 height=230
                        style="margin:5px; border:2px solid red; background-color:rgb(236, 236, 236); width:30vmin; height:30vmin"
                        title="Use Ctrl-S or double clicking in the call history to save floor here."></canvas>
                </div>
            </div>
        </div>
    </div>
    <!-- The instructions -->
    <div style="flex-grow:1; margin:5px; overflow: auto; min-width: 200px;">
        <h2>Instructions</h2>
        This is a program that simulates square dance calls for a 6 couple rectangle.
        This was inspired by the
        <a href="https://www.tamtwirlers.org/taminations/#?main=SEQUENCER&formation=Squared%20Set" target="_blank">
            Taminations sequencer</a>. You can get the definitions for Mainstream square dance calls at
        <a href="https://www.tamtwirlers.org/taminations/#?level=Basic%20and%20Mainstream&main=LEVELS&detail=CALLS"
            target="_blank">
            Taminations mainstream list</a>.
        <h2>Quick Start</h2>
        <p>
            If the instructions are hard to see, resize the window to be short and wide.
            On a phone turn it to the landscape view.
        </p>
        <p>
            To get started type the <strong>bold abbreviations</strong> (one line at a time) in the 'Enter Calls'
            textbox.
        </p>
        <ul>
            <li><strong>h pto</strong> (<strong>H</strong>eads <strong>P</strong>ass <strong>T</strong>he
                <strong>O</strong>cean)</li>
            <li><strong>ex</strong> (<strong>Ex</strong>tend)</li>
            <li><strong>st</strong> (<strong>S</strong>wing <strong>T</strong>hru)</li>
            <li><strong>br</strong> (<strong>B</strong>oys <strong>R</strong>un)</li>
            <li><strong>fw</strong> (<strong>F</strong>erris <strong>W</strong>heel)</li>
            <li><strong>c sq3</strong> (<strong>C</strong>enters <strong>Sq</strong>uare thru <strong>3</strong>)</li>
        </ul>
        <p>
            Notice each time you type a call it shows the end formation. It also shows the beginning formation
            in the 'Previous floor' area. When the square is resolved it will chirp, and also display a notification.
        </p>
        <p>
            You can use the <strong>up and down arrow keys</strong> or click on entries in the 'Call History' area
            to review previous calls.
            The <strong>left and right arrow keys</strong> jump to the first or last call in the call history.
        </p>
        <p>
            At any time you can type <strong>Ctrl-S</strong> (Save) to remember the currently displayed floor in the
            'Saved floor' area.
            You can also double click on any call in the call history to save the floor after that call.
        </p>
        <p>
            You can clear the call history with the <strong>reset</strong> (or Ctrl-R) button and undo the
            last call with the <strong>undo</strong> (or Ctrl-Z) button. You can also practice remembering dancers by
            using the 'hide' button to give each dancer a random color. Resetting the square does NOT
            change the colors, but hitting the 'hide' button when there are no calls WILL change the colors.
        </p>
        <h2>More Details on Usage</h2>
        <ul>
            <li> Calls are given very short abbreviations that are mostly the first letter of
                each word in the call (exception below). When using the first letter of of each
                word would be ambiguous (e.g st is Swing Thru or Square Thru), we either use
                the next letter (e.g Extend = ex) or the LAST consonant (e.g. StaR Thru = srt).</li>
            <li>One word calls typically have the first syllable. (e.g. recycle = rec)</li>
            <li> Dancer Designators are all one letter, and separated from the call by space
                (h=heads, s=sides, c=centers, e=ends, v = very centers) </li>
            <li> Calls Available: <strong><span id=allCalls></span></strong> </li>
            <li>Couples circulate is the same as circulate so we don't have that call.</li>
            <li> Typically you must explicitly call step to a wave (stw) from facing couples (st is an exception).</li>l
            <li> You can paste multiple commands (separated by space or a ;) into textbox.</li>
        </ul>
        <h2>New/Changed Calls</h2>
        There are a few calls that are either new, or need an explanation for dancers to be successful.
        You are encouraged to try these out in the simulator to confirm you understand
        what they do.
        <ul>
            <li>
                <strong>Wheel and Deal</strong> (whd) - When called from lines facing out, there are
                three couples facing out. The outside two couples do what they would normally do, the very center
                couple does a partner trade (and become the very centers of the triple pass through formation).
            </li>
            <li><strong>First Couple go Left Next Right</strong> (flnr) - This starts in a completed triple pass
                through formation and again the first two couples do what they would have done in a 4 couple square.
                The last couple does a partner trade, and together they all form a line facing in.
            </li>
            <li><strong>Bend the line</strong> - When there are 2 rows of 6 dancers facing, you can bend the
                line but the simulator currently does not support it because the flow is so bad. However bending
                a line of 6 facing out does flow well, and so this is supported. Bending from two faced
                lines of 4 also is legal and supported.
            </li>
            <li><strong>Triple Pass Thru</strong> (tpt) - This works just like double pass through, however
                you pass 3 people and end in a completed triple pass through (facing out or someone's back).
            </li>
            <li><strong>Centers and Very Centers</strong> (c and v) - Ends or outsides work as before. However There
                are now 4 couples that are in the center not just 2. However it is useful to have only the most
                central 2 couples do something, and they are referred to as the 'very centers'.
            </li>
            <li><strong>Stretch Ferris Wheel</strong> - normal <strong>Ferris Wheel</strong> works and is supported,
                but it is useful to be able to form triple pass through formation (after all, in a 4 couple square
                a <strong>Ferris Wheel</strong> makes a double pass through formation). To achieve this, we ask the
                dancers facing in to not <strong>Wheel And Deal</strong> with the first couple they meet but the second.
            </li>
        </ul>
        <h2>Modules Work on 6 Couple Squares</h2>
        <p>
            It is surprising (at least to me), that MOST square dance figures that work in 4 couple squares
            <strong>also work in 6 couple squares</strong>. The main caveats
        <ul>
            <li><strong>Promenade 1/2</strong> is <strong>NOT</strong> equivalent to a
                <strong>Heads Right and Left Thru</strong>. The problem is that a promenade swaps
                the head dancer couples left-right as well as front-back. If you substituted
                a <strong>Heads Right and Left Thru</strong> for the <strong>Promenade 1/2</strong>
                the figure would likely work.
                <p>
                    Note that figures that get you 'across the street', still all work
                    (they are equivalent to a <strong>Heads Right and Left Thru</strong>)
                    Thus things like
                    <strong>Heads Square Thru 2</strong>, <strong>Heads Pass the Ocean, Extend</strong>,
                    or the use a 1/2 chicken plucker (RLT-PT-TB), all work.
                </p>
            </li>
            <li>Anything that creates 4 groups of 3, rather than 3 groups of 4 is not likely to work
                without modification.
                This includes bending a line of 6 as well as anything dealing with a triple pass
                through formations. Thus things that will need modification include
                <ul>
                    <li><strong>Tag the Line</strong></li>
                    <li><strong>Cloverleaf</strong></li>
                    <li><strong>Wheel and Deal</strong> (facing out, 2-faced is OK)</li>
                    <li><strong>Bend the Line</strong> (of 6, 4 is OK)</li>
                </ul>
                Note that figures that form triple pass through formation can often be fixed
                simply by adding a extra <strong>Zoom</strong>. For example the zero
                <ul>
                    <li>PT, WHD, TPT, FLNR</li>
                </ul>
                works in a 4 couple square but NOT a 6 couple square, but adding a zoom makes
                it a zero for a 6 couple square.
                <ul>
                    <li>PT, WHD, ZOOM, TPT, FLNR</li>
                </ul>
            </li>
        </ul>
        In short, probably most of your most popular figures 'just work'. This means that you
        can call a six couple square immediately (just stick with modules you know work).

        <h2>Resolving</h2>
        Resolving a 6 couple square is not much harder than a 4 couple square. The hardest part is that you have
        to remember 3 couples (not just 2) to know what to do. Any three in a row will work, but for the sake of
        discussion, we will assume that the three couples are the side couple #6 and the couples on either side (#5 and
        #1). In general you have to remember all 6 of these people to resolve.

        The general technique for resolution is as follows
        <ul>
            <li><strong>Get your focus couple coupled up</strong> - You can do this many ways one way si to get to
                ocean waves and then use all-8 circulate one gender circulates to match them up.
            </li>
            <li><strong>Get that couple to lines of 6 facing in</strong> - (recycle bend the line will do it)</li>
            <li><strong>Call Wheel and Deal</strong> - this makes a triple pass through formation.</li>
            <li><strong>Get your focus couple to the ENDS position</strong> - call <strong>Zoom</strong> enough times to
                do this.</li>
        </ul>
        You have now resolved the ends (your focus couple). However importantly because you are in a
        triple pass thru configuration
        you can operate on JUST 2 couples (the very centers) or 4 couples (the centers)
        <strong>without disturbing</strong> what you have already resolved.
        This is the key to the resolution technique. The next step is to
        get all the 'neighbors' (couple #1 and #5) of your focus couple (#6) next to that focus couple. The
        operations you have are
        <ul>
            <li><strong>Very Centers FlutterWheel</strong>- Look at
                the two pairs of dancers in the very center. Either they BOTH go to one side or there
                is a mix (one needs to go to one side and the other needs to go in the opposite direction).
                In this later case, use <strong>Very Centers FlutterWheel</strong>
                to fix it so that each couple on one side of the very centers both need to go in the
                same direction.
            </li>
            <li><strong>Very Centers Pass thru or Square thru 3 </strong> - Once the
                very centers need to go the same way, you use either a <strong>Very Centers Pass Thru</strong> or
                a <strong>Very Centers Square Thru 3</strong> to get them on the correct side
                facing the other center couple.
            </li>
        </ul>
        <p>
            As this point the OTHER center couple might contain dancers that are on the wrong side. if This
            happens, then you need to do a <strong>Centers Pass To the Center</strong>. This bring these outside
            centers to the very center. You can the repeat the process of using FL, RFL, and V PT or V SQ3 to
            get these dancers to the correct side.
        </p>
        <p>
            Now that have all the neighbors of your focus couple near your focus couple you are almost
            there. The procedure from here works EXACTLY like in the 4 couple case. There are two cases.
        </p>
        <ul>
            <li><strong>The all dancers are paired up</strong> - in this case do a <strong>Centers Pass Thru,
                    Veer Left, and Bend the Line.</strong> This forms lines of couple up dancers. Then just like
                in 4 couple resolution, you can either do a <strong>Star Thru, Square Thru 3</strong> or
                a <strong>Star Thru, Pass Thru</strong> to complete the resolution.

            </li>
            <li><strong>The neighbor dancers are mixed</strong> - this work JUST LIKE 4 couple resolution. Either
                a <strong>Centers Pass Thru</strong> or a <strong>Centers Square Thru 3</strong> will resolve
                the square.
            </li>
        </ul>
        <p>
            There are many variations on this basic theme as well as shortcuts etc. For example you can use
            <strong>Stretch Ferris Wheel</strong> instead of <strong>Wheel and Deal</strong> to get to the
            triple pass through formation. There are plenty of alternatives to <strong>FlutterWheel</strong>
            which swap dancers in a box. These could be used instead. There are many such variations.
            The key insight however, is that 'very centers' and 'centers' let you fix the inner part of the
            square without disturbing the ends.
            The other important insight is that it is enough to get the neighbors of your focus couple to the
            correct half of the square. The rest works like 4 couple resolution.
        </p>
        <p>
            You will quickly find that the hardest part of resolving a 6 couple square
            is remembering where the dancer's home position is.   To help in practicing 
            this you can press the 'hide' button which removes the numbers an consistent
            coloring of the dancers.  Instead they are given random colors.   You will find
            it much more difficult to resolve under these conditions (which mimic real world
            conditions better).   If you forget dancers belong you can 'peek' by clicking
            the 'identify' button and again to go back.   You can also hit the left arrow
            to see the first position of the square (which tells you where home is) and then 
            it the right arrow key to go back.   When you wish to get a new set of colors
            to try, you need only hit the 'hide' key when the dancers are reset.  Thus you can 
            keep hitting 'hide' if on a reset square to keep getting new sets of colors.  
        </p>
        <h2>Singing Calls (Corner Progression)</h2>
        You can even do singing calls with corner progression with 6 couples.
        The following modifications are needed.
        <ul>
            <li>You will need 6 figures instead of 4 to get all the way around. Thus you
                need sacrifice your closer and middle-bridge and use them for figures (thus you only
                have an opener). Thus you need to pick music that is uniform for all 7 parts of
                the dance.
            </li>
            <li>Singing call figures have a promenade at the end which is now LONGER,
                so choose SHORT figures.</li>
            <li>In your opener, try to call the first <strong>Allemande Left</strong> early to
                cut the amount of <strong>Circle-Left</strong> time you do. This will make up for some of the extra
                time that will be needed to do the weave the ring and promenade.
            </li>
            <li>Surprisingly, you can do a grand square in 6 couple squares.
                The key is that the 'very center heads' have to turn AWAY form
                the center of the square which is OPPOSITE what they are used to.
                They end up being in TANDEM with their partner as the do the
                move, which is what makes it all work. It is definitely something
                you want to have your dancers practice first. The grand-square
                takes the same amount of time, however you will need more time
                for the promenade, so it is OK that dancers go fast on this one.
            </li>
        </ul>
    </div>
    <!-- *************************** END OF HTML ******************************* -->
    <script>
        "use strict";                // do extra error checking at load time

        /***********************************************************************/
        // STARTUP code.   This initializes global constants, GUI constants, 
        // and the model for the program (the dance floor)

        // Global CONSTANTS 
        // get GUI objects needed
        const g_mainCanvas = document.getElementById('main');
        const g_prevCanvas = document.getElementById('prev');
        const g_savedCanvas = document.getElementById('saved');
        const g_savedCallNumSpan = document.getElementById('savedCallNum');
        const g_messageSpan = document.getElementById('message');
        const g_allCallsSpan = document.getElementById('allCalls');
        const g_resolvedsSpan = document.getElementById('resolved');
        const g_callListOrderedList = document.getElementById('callList');
        const g_callInput = document.getElementById('call');
        const g_identifyButton = document.getElementById('identify');

        // Values for dancers based on their dancer number 
        const COLORS = [
            "red", "green", "cyan", "yellow", "violet", "blue",
            "black", "goldenrod", "lawngreen",
            "#5C5C5C", // dark gray
            "#C5C5C5", // light gray
            "#44C9D4", // deep aqua
            "#55478C", // dark blue
            "#774D18", // deep brown
            "#9F027A", // dark pink
        ];

        // Values for dancer.rotation.  These work like map directions
        const NORTH = 0;
        const WEST = 1;
        const SOUTH = 2;
        const EAST = 3;

        // commands maps call names to the method that performs it used in doCommand
        const CALL_TO_FTN = getCallFtns();

        /****************************************/
        // Global MUTABLE state (the model)

        // The model is embodied in a single structure the history list.
        // Each element in this list is a call, along with its floor before 
        // the call, and the floor after the call.   
        let g_callHistory = [];

        // on reset we remember our last call history, so that you can undo it.  
        let g_lastCallHistory = undefined;

        // This is the start of the 'viewModel' state.  This is information that the GUI
        // keeps track of but arguably is not part of the model because it makes sense
        // for the GUI, but not for an API for the model 
        let g_callListSelectedItemIdx = -1;      // initialized to be g_callHistory.length-1
        // This is the index into g_callList that is shown in the 'saved floor'
        let g_callListSavedIdx = -1;
        // Are the coupled identified by color/number?
        let g_couplesIdentified = true;
        let g_dancerColorsBoys;     // If we choose random colors these are the colors. (array based on dancer number)
        let g_dancerColorsGirls;

        // Run any startup needed to get the GUI in the desired start up state.
        startup();

        /*******************************************************************/
        // END OF STARTUP CODE.   
        // The rest of this code is function declarations that have no
        //  effect at the time the are scanned by javascript.
        /*******************************************************************/

        /********************************************************************/
        // code that is run at startup 
        function startup() {

            // tell the user all the calls available. (g_allCallsSpan)
            let allCalls = []
            for (let key in CALL_TO_FTN)
                allCalls.push(key);
            allCalls.push("reset");        // add meta-calls
            allCalls.push("undo");
            allCalls.push("id");
            allCalls.sort();
            g_allCallsSpan.innerHTML = allCalls.join(", ");

            syncGUIToModel();
        }

        /********************************************************************/
        // operations on a single dancer (note deltas can be negative to move in the opposite direction)

        // moves a dancer in a given direction and changes its rotation.
        // parameters can be negative 
        function dancerMove(dancer, forwardDelta, slideRightDelta, rotateCCWDelta) {
            console.assert(dancer.gridX == Math.floor(dancer.gridX));        // integer value
            console.assert(dancer.gridY == Math.floor(dancer.gridY));        // integer value

            if (dancer.rotation == NORTH) {
                dancer.gridY += forwardDelta;
                dancer.gridX += slideRightDelta;
            }
            else if (dancer.rotation == WEST) {
                dancer.gridY += slideRightDelta;
                dancer.gridX -= forwardDelta;
            }
            else if (dancer.rotation == SOUTH) {
                dancer.gridY -= forwardDelta;
                dancer.gridX -= slideRightDelta;
            }

            else if (dancer.rotation == EAST) {
                dancer.gridY -= slideRightDelta;
                dancer.gridX += forwardDelta;
            }

            // spin the given amount
            rotateCCWDelta += 4;
            dancer.rotation = (dancer.rotation + rotateCCWDelta) % 4;
        }

        // returns the amount to add (+1 or -1) to step forward
        function dancerForwardValue(dancer) {
            return (dancer.rotation == NORTH || dancer.rotation == EAST) ? 1 : -1;
        }

        // gets the coordinate of dancer (gridX or gridY) in its facing direction
        // thus if you are facing heads, you get gridY (since you move in this direction forward and back)
        function dancerGetFacingCoordinate(dancer) {
            if (dancerIsFacingHeads(dancer))
                return dancer.gridY;
            else
                return dancer.gridX;
        }

        // gets the direction that you change to move left or right.   
        function dancerGetCrossCoordinate(dancer) {
            if (dancerIsFacingHeads(dancer))
                return dancer.gridX;
            else
                return dancer.gridY;
        }

        function dancerScaleFacingCoordinate(dancer, factor) {
            if (dancerIsFacingHeads(dancer))
                dancer.gridY = Math.round(dancer.gridY * factor);
            else
                dancer.gridX = Math.round(dancer.gridX * factor);
        }

        // a deep copy (which is also a shallow copy) of a dancer (used to make a deep copy of the floor)
        function dancerCopy(dancer) {
            let ret = Object.assign({}, dancer);
            return ret;
        }

        function dancerIsSides(dancer) {
            return dancer.number == 3 || dancer.number == 6;
        }
        function dancerIsHeads(dancer) {
            return !dancerIsSides(dancer);
        }

        function dancerIsFacingHeads(dancer) {
            return dancer.rotation % 2 == 0;
        }

        function dancerIsFacingSides(dancer) {
            return dancer.rotation % 2 == 1;
        }

        /********************************/
        // operations on two dancers 

        function swapPos(dancer1, dancer2) {
            let temp = dancer1.gridX;
            dancer1.gridX = dancer2.gridX;
            dancer2.gridX = temp;

            temp = dancer1.gridY;
            dancer1.gridY = dancer2.gridY;
            dancer2.gridY = temp;
        }

        function trade(dancer1, dancer2) {
            swapPos(dancer1, dancer2)
            dancerMove(dancer1, 0, 0, 2);
            dancerMove(dancer2, 0, 0, 2);
        }

        // In a sorted list of dancers, determine how long the 
        // line is (if you look to your right, how many people
        // do you see with the same facing coordinate).   
        function dancersLineLen(dancers, start = 0) {
            let gridY = dancerGetFacingCoordinate(dancers[start]);
            let i;
            for (i = start + 1; i < dancers.length; i++) {
                if (dancerGetFacingCoordinate(dancers[i]) != gridY)
                    break;
            }
            return i - start;
        }

        // given a list of dancers THAT ARE SORTED, return a array of boxes.   
        // a box is a array of 4 dancers.  Logically the dancers in the box
        // are arranged like
        //     2 3
        //     0 1 
        function dancersGetBoxes(dancers) {
            let lineLen = dancersLineLen(dancers);
            if (lineLen % 2 != 0 || dancers.length % (lineLen * 2) != 0)
                throw "Bad formation (can't find boxes).";

            let ret = []
            for (let boxI = 0; boxI < dancers.length; boxI += 2 * lineLen) {
                for (let i = 0; i < lineLen; i += 2)
                    ret.push([dancers[i + boxI], dancers[i + 1 + boxI],
                    dancers[lineLen + i + boxI], dancers[lineLen + i + 1 + boxI]]);
            }
            return ret;
        }

        // given a list of dancers THAT ARE SORTED, return a array of lines of 4 dancers
        // the dancers are arranged from left to right if you face NORTH-SOUTH
        // and arranged top to bottom if you face EAST-WEST
        function dancersGetLinesOf4(dancers) {
            let lineLen = dancersLineLen(dancers);
            if (lineLen != 4)
                throw "Bad formation (can't find lines of 4).";

            return [dancers.slice(0, 4), dancers.slice(4, 8), dancers.slice(8, 12)];
        }

        // returns true if the two dancers are facing
        function dancersIsFacingOpposite(dancer1, dancer2) {
            return Math.abs(dancer1.rotation - dancer2.rotation) == 2;
        }

        function dancerFacingAwayFromCenter(dancer) {
            let forward = dancerForwardValue(dancer);                               // 1 if going away from origin
            let normalizedPos = dancerGetFacingCoordinate(dancer) >= 0 ? 1 : -1;    // 1 if origin at my back.  
            return forward == normalizedPos;
        }

        /********************************************************************/
        /********************************************************************/
        // operations on the floor  
        // the floor consists of a set of (in our case 12) dancers 

        // Some important invariants of floor
        //   * gridX and gridY are always small INTEGERS less than 6 in absolute value
        //   * The origin of this grid is the very center of the rectangle of dancers 
        //     in the GUI the origin is marked with a cross
        //   * X grows to the right, Y grows up (like in Math, NOT like in graphics)
        //   * a dancer's rotation is always a number 0-3 (see NORTH, SOUTH, EAST, WEST)

        function floorReset(floor) {
            if (floor == undefined)
                floor = {};
            floor.dancers = [];
            floor.isResolved = false;

            floorMakeCouple(floor.dancers, 1, -3, -3, NORTH);
            floorMakeCouple(floor.dancers, 2, 1, -3, NORTH);
            floorMakeCouple(floor.dancers, 3, 5, -1, WEST);
            floorMakeCouple(floor.dancers, 4, 3, 3, SOUTH);
            floorMakeCouple(floor.dancers, 5, -1, 3, SOUTH);
            floorMakeCouple(floor.dancers, 6, -5, 1, EAST);

            return floor;
        }

        // makes a deep copy of the floor.  
        function floorDeepCopy(floor) {
            // do a shallow copy 
            let ret = Object.assign({}, floor);

            // Need a deeper copy of the dancers
            ret.dancers = [];
            for (let dancer of floor.dancers)
                ret.dancers.push(dancerCopy(dancer));
            return ret;
        }

        function floorMakeCouple(dancers, number, gridX, gridY, rotation) {

            // Create the boy dancer
            dancers.push({ isBoy: true, number: number, rotation: rotation, gridX: gridX, gridY: gridY });
            // create the girl dancer
            let girl = { isBoy: false, number: number, rotation: rotation, gridX: gridX, gridY: gridY };
            dancerMove(girl, 0, 2, 0);

            dancers.push(girl);
        }

        /***********************************************************************/
        // Operations for figuring out what formation you have

        // returns true if the dancer is facing out of the entire formation
        function floorIsFacingOut(floor, dancer) {

            // step forward tentatively
            let stepForward = dancerGetFacingCoordinate(dancer) + dancerForwardValue(dancer);

            // did we leave the formation?
            return stepForward < floor.minFacing || floor.maxFacing < stepForward;
        }

        function cmpOrder(val1, val2) {
            if (val1 != 0)
                return val1;
            return val2;
        }

        function floorIsResolved(floor) {
            let dancers = floor.dancers;

            // We iterate through the dancers 'around the outside counter clockwise' (promenade order)
            // this gets us the sequence 0 2 4 6 8 10 11 9 7 5 3 1 
            function dancerLoc(dancer) { return (dancer < 6) ? (2 * dancer + 1) : (10 - 2 * (dancer - 6)); }

            //  first transform 1-6 to 0-5 then add one then mod, then translate back.  
            function dancerNextNum(num) { return num % 6 + 1; }

            for (let i = 0; i < 12; i++) {
                let curDancer = dancers[dancerLoc(i)];
                let nextDancer = dancers[dancerLoc((i + 1) % 12)];
                if (nextDancer.isBoy == curDancer.isBoy)    // we alternate genders
                    return false;

                if (curDancer.isBoy) {                      // the next needs to be your partner
                    if (nextDancer.number != curDancer.number)
                        return false;
                }
                else {                                      // next dancer is the girls corner
                    if (nextDancer.number != dancerNextNum(curDancer.number))
                        return false

                    // either you are facing your corner or you are both facing out
                    if (floorIsFacingOut(floor, curDancer)) {
                        if (!floorIsFacingOut(floor, nextDancer))
                            return false;
                    }
                    else {
                        if (!dancersIsFacingOpposite(nextDancer, curDancer))
                            return false;
                    }
                }
            }
            return true;
        }

        // given a designator (e.g. c = centers, e = ends, v = very centers, h = heads, s = sides) 
        // return an array of those dancers.  The returned dancers are sorted 
        // * left to right if the dancers are facing NORTH or SOUTH
        // * top to bottom if the dancers are facing EAST or WEST  
        // In particular this makes the dancers paired up.  
        function floorGetDancers(floor, designator) {

            let dancers = floor.dancers;
            let isDesignatedHeadsOrSides = false;

            if (designator == "h") {
                dancers = [];
                for (let dancer of floor.dancers) {
                    if (dancerIsHeads(dancer))
                        dancers.push(dancer)
                }
                isDesignatedHeadsOrSides = true;
            }
            else if (designator == "s") {
                dancers = [];
                for (let dancer of floor.dancers) {
                    if (dancerIsSides(dancer))
                        dancers.push(dancer)
                }
                isDesignatedHeadsOrSides = true;
            }

            // Sort the dancers so that all couples are next to each other.  couples go from FLOOR left to right
            // (thus sashayed couples might be surprising)
            if (dancerIsFacingHeads(dancers[0]))
                dancers.sort((a, b) => cmpOrder(a.gridY - b.gridY, a.gridX - b.gridX)); // sort by Y A->Z then X A->Z
            else
                dancers.sort((a, b) => cmpOrder(a.gridX - b.gridX, b.gridY - a.gridY)); // sort by X A->Z then Y Z->A

            floor.minFacing = dancerGetFacingCoordinate(dancers[0]);
            floor.maxFacing = dancerGetFacingCoordinate(dancers[dancers.length - 1]);

            if (isDesignatedHeadsOrSides || !designator)
                return dancers;

            // This is one of the places we care that we have 12 dancers
            console.assert(dancers.length == 12);

            // TODO fail if the formations are wrong for the designator (currently we blindly apply) 

            let lineLen = dancersLineLen(dancers);
            if (designator == "v") {
                if (lineLen == 2)
                    return dancers.slice(4, 8);
                else if (lineLen == 6)
                    return dancers.slice(2, 4).concat(dancers.slice(8, 10));
                else
                    throw "Can't Determine Very Centers.";
            }
            if (designator == "c") {
                if (lineLen == 2)
                    return dancers.slice(2, 10);
                else if (lineLen == 4)
                    return [dancers[1], dancers[2], dancers[5], dancers[6], dancers[9], dancers[10]];
                else if (lineLen == 6)
                    return dancers.slice(1, 5).concat(dancers.slice(7, 11));
                else
                    throw "Can't Determine Centers.";
            }
            if (designator == "e") {
                if (lineLen == 2)
                    return [dancers[0], dancers[1], dancers[10], dancers[11]];
                else if (lineLen == 4)
                    return [dancers[0], dancers[3], dancers[4], dancers[7], dancers[8], dancers[11]];
                else if (lineLen == 6)
                    return [dancers[0], dancers[5], dancers[6], dancers[11]];
                else
                    throw "Can't Determine Ends.";
            }
            if (designator == "g" || designator == "b") {
                let wantBoy = (designator == "b");
                dancers = [];
                for (let dancer of floor.dancers) {
                    if (dancer.isBoy == wantBoy)
                        dancers.push(dancer)
                }
                return dancers;
            }
            throw "Unsupported Designator " + designator;
        }

        // when you have a heads or side designator, the dancers may not be
        // on the grid to start with.   Move them to the grid.
        function dancersMoveDancersToGrid(dancers, designator) {
            if (designator === "h" || designator === "s") {
                for (let dancer of dancers)
                    dancerScaleFacingCoordinate(dancer, Math.abs(1 / dancerGetFacingCoordinate(dancer)));
            }
        }

        // Validates the floor and returns an error message if the floor is bad.
        // returns undefined if the floor is valid.  
        function floorFindError(floor, designator, callFtn) {
            let dancers = floorGetDancers(floor);
            if (dancers.length != 12)
                return "Not 12 dancers";

            // TODO FIX: we turn off checking, we can do better. 
            if ((designator == "h" || designator == "s") && callFtn == doPromHalf) {
                return undefined;
            }

            // Can only have these lengths
            let lineLen = dancersLineLen(dancers);
            if (lineLen != 2 && lineLen != 4 && lineLen != 6 && lineLen != 12)
                return "Bad Line Length";

            let dancersFacingHeads = dancerIsFacingHeads(dancers[0]);
            for (let dancer of dancers) {
                if (dancerIsFacingHeads(dancer) != dancersFacingHeads)
                    return "T-Bone configuration for dancer";
                if (5 < Math.abs(dancer.gridX) || 5 < Math.abs(dancer.gridY))
                    return "Dancer outside Grid";
                if (Math.floor(dancer.gridX) != dancer.gridX || Math.floor(dancer.gridY) != dancer.gridY)
                    return "Dancer not on integral grid locations";
            }

            // two dancers can't have the same spot.  
            for (let i = 1; i < dancers.length; i++) {
                if (dancers[i - 1].gridX == dancers[i].gridX && dancers[i - 1].gridY == dancers[i].gridY)
                    return "Two dancers on the same spot";
            }

            // there is mirror symmetry
            for (let i = 0; i < dancers.length / 2; i++) {
                if (dancers[i].gridX != -dancers[dancers.length - 1 - i].gridX)
                    return "Mirror fails for X for dancer " + i;
                if (dancers[i].gridY != -dancers[dancers.length - 1 - i].gridY)
                    return "Mirror fails for Y for dancer " + i;

                if (!dancersIsFacingOpposite(dancers[i], dancers[dancers.length - 1 - i]))
                    return "Mirror fails on Direction for dancer " + i;
            }

            if (lineLen == 2 && dancersLineLen(dancers, 2) == 4) {
                // It is a quarter tag [position].  dancer 0 should be able to 
                // move forward 3 spaces and land on the dancer 3
                if (dancerGetFacingCoordinate(dancers[3]) - dancerGetFacingCoordinate(dancers[0]) != 3)
                    return "Bad Quarter Tag Formation end spacing";

                if (dancerGetCrossCoordinate(dancers[3]) != dancerGetCrossCoordinate(dancers[0]))
                    return "Bad Quarter Tag Formation left-right";

                dancers = floorGetDancers(floor, "c");  // just keep the centers
            }
            else if (lineLen == 4 && dancersLineLen(dancers, 4) == 2) {  // only valid for home position
                if (dancers[0].rotation != NORTH || dancers[4].rotation != EAST || dancers[5] != WEST)
                    return "Bad Home Position ";
                dancers = floorGetDancers(floor, "h");      // just keep the heads  
            }
            else {
                // We can tighten up where the dancers can be for the lines of 6 or columns case.   
                for (let dancer of dancers) {
                    if (lineLen == 6 && Math.abs(dancerGetFacingCoordinate(dancer)) != 1 ||
                        lineLen == 2 && Math.abs(dancerGetCrossCoordinate(dancer)) != 1)
                        return "Dancer off Grid";

                    // Symmetry on the grid makes it unusual that dancers are on an axis 
                    // Only in odd line configure
                    if (dancerGetCrossCoordinate(dancer) == 0)
                        return "Dancers not symmetric in side-to-side dimension";
                    if (dancerGetFacingCoordinate(dancer) == 0 && (12 / lineLen) % 2 != 1)
                        return "Dancers not symmetric in front-back dimension";
                }
            }

            // Check The dancers are in a perfect rectangle on a grid 
            lineLen = dancersLineLen(dancers);
            let distBetweenLines = 0;        // means we did not init it.  
            let distBetweenDancers = Math.abs(dancerGetCrossCoordinate(dancers[1]) - dancerGetCrossCoordinate(dancers[0]));
            for (let lStart = 0; lStart < dancers.length; lStart += lineLen) {
                if (distBetweenLines == 0 && 0 < lStart)
                    distBetweenLines = Math.abs(dancerGetFacingCoordinate(dancers[lStart]) - dancerGetFacingCoordinate(dancers[0]));

                Math.abs(dancerGetFacingCoordinate(dancers[lStart]) - dancerGetFacingCoordinate(dancers[0]))

                for (let i = 1; i < lineLen; i++) {
                    let rlDist = Math.abs(dancerGetCrossCoordinate(dancers[lStart + i]) - dancerGetCrossCoordinate(dancers[lStart + i - 1]));
                    if (rlDist != distBetweenDancers)
                        return "Dancers not equally spaced left to right";

                    if (distBetweenLines != 0) {
                        let fbDist = Math.abs(dancerGetFacingCoordinate(dancers[lStart + i]) - dancerGetFacingCoordinate(dancers[lStart + i - lineLen]));
                        if (fbDist != distBetweenLines)
                            return "Dancers not equally spaced forward and back";
                    }
                }
            }

            return undefined;   // success (there is no error)
        }

        /*******************************************************************/
        /*                        SQUARE DANCE CALLS                       */

        /********************************************************************/

        function doHome(floor) {
            floorReset(floor);
        }

        /*******************************/
        /* Basic 1 calls */

        function doAllemandeLeft(floor, dancers) {
            if (!floor.isResolved)
                throw "Alemande Left on an unresolved square";
        }

        function doPassThru(floor, dancers) {
            for (let dancer of dancers) {
                if (floorIsFacingOut(floor, dancer))
                    throw "Dancers facing out can't pass thru";
                dancerMove(dancer, 2, 0, 0);
            }
        }

        function doTrade(floor, dancers) {
            for (let i = 0; i < dancers.length; i += 2) {
                trade(dancers[i], dancers[i + 1]);
            }
        }

        function doRightAndLeftThru(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                for (let beau of [box[0], box[3]])
                    dancerMove(beau, 2, 2, 2);
                for (let belle of [box[1], box[2]])
                    dancerMove(belle, 2, -2, 2);
            }
            floor.sweepCCW = 1;
        }

        function doStarThru(floor, dancers) {
            for (let dancer of dancers)
                dancerMove(dancer, 2, 0, dancer.isBoy ? -1 : 1);
        }

        function doLeadRight(floor, dancers) {
            for (let i = 0; i < dancers.length; i++) {
                let dancer = dancers[i];
                let beauFactor = (dancer.isBoy ? 1 : 0)           // TODO this should not be sex base.
                dancerMove(dancers[i], 2 * beauFactor, 2 * beauFactor, -1);
            }
        }

        function doSquareThru4(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                dancerMove(box[0], 0, 0, 1);
                dancerMove(box[1], 0, 0, -1);
                dancerMove(box[2], 0, 0, -1);
                dancerMove(box[3], 0, 0, 1);
            }
        }

        function doSquareThru2(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                dancerMove(box[0], 2, 2, -1);
                dancerMove(box[1], 2, -2, 1);
                dancerMove(box[2], 2, -2, 1);
                dancerMove(box[3], 2, 2, -1);
            }
        }

        function doVeerLeft(floor, dancers) {
            for (let dancer of dancers)
                dancerMove(dancer, 1, -2, 0);
        }

        function doCirculate(floor, dancers) {

            // figure out how far to walk forward
            let lineLen = dancersLineLen(dancers);
            let peopleInLine = dancers.length / lineLen;
            let delta = Math.abs(floor.maxFacing - floor.minFacing) / (peopleInLine - 1);

            for (let dancer of dancers) {
                if (floorIsFacingOut(floor, dancer)) {
                    if (dancerIsFacingHeads(dancer))
                        dancer.gridX = -dancer.gridX;         // flip the other side
                    else
                        dancer.gridY = -dancer.gridY;         // flip the other side
                    dancerMove(dancer, 0, 0, 2);              // flip direction
                }
                else
                    dancerMove(dancer, delta, 0, 0);
            }
        }

        function doChainDownTheLine(floor, dancers) {
            for (let line of dancersGetLinesOf4(dancers)) {
                for (let end of [line[0], line[3]])
                    dancerMove(end, 1, 2, -1);
                for (let center of [line[1], line[2]])
                    dancerMove(center, 1, 2, 1);
            }
            floor.sweepCCW = 1;
        }

        function doTurnBack(floor, dancers) {
            for (let dancer of dancers)
                dancerMove(dancer, 0, 0, 2);
        }

        function doHalfSashay(floor, dancers) {
            for (let i = 0; i < dancers.length; i += 2) {
                if (dancersIsFacingOpposite(dancers[i], dancers[i + 1]))
                    throw "Must be a couple (facing same direction)"
                swapPos(dancers[i], dancers[i + 1]);
            }
        }

        function doFaceIn(floor, dancers) {
            let lineLen = dancersLineLen(dancers);

            let needFaceEastWest;
            if (lineLen == 2) {    // column-like
                needFaceEastWest = dancerIsFacingHeads(dancers[0]);
            }
            else if (lineLen == 6) {
                needFaceEastWest = dancerIsFacingSides(dancers[0]);
            }
            else
                throw "Bad Formation for Face In";

            for (let i = 0; i < dancers.length; i++) {
                if (needFaceEastWest) {
                    if (dancers[i].gridX < 0)
                        dancers[i].rotation = 3;
                    else
                        dancers[i].rotation = 1;
                }
                else {
                    if (dancers[i].gridY < 0)
                        dancers[i].rotation = 0;
                    else
                        dancers[i].rotation = 2;
                }
            }
        }

        function doPromHalf(floor, dancers) {
            let isSides = dancerIsSides(dancers[0]);
            for (let i = 0; i < dancers.length / 2; i++) {
                if (dancerIsSides(dancers[i]) != isSides)
                    throw "Dancers must be all heads or all sides";
                swapPos(dancers[i], dancers[dancers.length - i - 1]);
                for (let dancer of [dancers[i], dancers[dancers.length - i - 1]])
                    dancerMove(dancer, 0, 0, 2);
            }
        }

        /*******************************/
        /* Basic 2 calls */

        function doExtend(floor, dancers) {
            let lineLen = dancersLineLen(dancers);
            let lineLen2 = dancersLineLen(dancers, 2);
            if (lineLen == 2 && lineLen2 == 4) {
                for (let i = 0; i < dancers.length; i++) {
                    dancerMove(dancers[i],
                        ((i <= 1 || 10 <= i) ? 1 : 2),                      // everyone but ends move forward
                        ((i == 0 || i == dancers.length - 1) ? -2 : 0), 0); // only end on the left slides over 2
                }
            }
            else
                throw "Expected QuarterTag";
        }

        function doSweepAQuarter(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                if (floor.sweepCCW == 1) {
                    dancerMove(box[0], 0, 2, 1);
                    dancerMove(box[1], 2, 0, 1);
                    dancerMove(box[2], 2, 0, 1);
                    dancerMove(box[3], 0, 2, 1);
                }
                else if (floor.sweepCCW == -1) {
                    dancerMove(box[0], 2, 0, -1);
                    dancerMove(box[1], 0, -2, -1);
                    dancerMove(box[2], 0, -2, -1);
                    dancerMove(box[3], 2, 0, -1);
                }
                else
                    throw "Sweep 1/4 requires previous call to have 2 dancer flow.";
            }
        }

        function doFlutterWheel(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                dancerMove(box[0], 2, 2, 2);
                dancerMove(box[3], 2, 2, 2);
            }
            floor.sweepCCW = -1;
        }

        function doReverseFlutterWheel(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                dancerMove(box[1], 2, -2, 2);
                dancerMove(box[2], 2, -2, 2);
            }
            floor.sweepCCW = 1;
        }

        function doPassTheOcean(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                for (let beau of [box[0], box[3]])
                    dancerMove(beau, 4, 1, -1);
                for (let belle of [box[1], box[2]])
                    dancerMove(belle, 2, -1, 1);
            }
        }

        function doSwingThru(floor, dancers) {
            // TODO swing thru is not correct for left handed waves (it does a left swing thru)

            // Allow the facing couple ocean wave rule TODO do this more uniformly. This is a hack
            let lineLen = dancersLineLen(dancers);
            if (lineLen == 2 && dancers.length == 12) {
                doStepToAWave(floor, dancers);
                return doSwingThru(floor, floorGetDancers(floor));
            }

            // check if the formation is valid
            for (let i = 1; i < dancers.length; i++) {
                if (!dancersIsFacingOpposite(dancers[i], dancers[i - 1]))
                    throw "Need to have alternating dancers" + (lineLen == 4 ? " (need to call stw?)" : "");
            }

            if (lineLen == 4) {
                for (let start = 0; start < dancers.length; start += lineLen) {
                    trade(dancers[start], dancers[start + 1]);
                    trade(dancers[start + 2], dancers[start + 3]);

                    // centers trade (note that we have to use the ORIGINAL indexes)
                    // to fetch people now in the center
                    trade(dancers[start], dancers[start + 3]);
                }
            }
            else if (lineLen == 6) {
                for (let start = 0; start < dancers.length; start += lineLen) {
                    trade(dancers[start], dancers[start + 1]);
                    trade(dancers[start + 2], dancers[start + 3]);
                    trade(dancers[start + 4], dancers[start + 5]);

                    // centers trade (note that we have to use the ORIGINAL indexes)
                    // to fetch people now in the center
                    trade(dancers[start], dancers[start + 3]);
                    trade(dancers[start + 2], dancers[start + 5]);
                }
            }
            else
                throw "Expected ocean waves.";
        }

        function doBoysRun(floor, dancers) {
            for (let i = 0; i < 12; i += 2) {
                if (dancers[i].isBoy == dancers[i + 1].isBoy)
                    throw "Same sex next to each other";

                swapPos(dancers[i], dancers[i + 1]);
                if (dancers[i].isBoy)
                    dancerMove(dancers[i], 0, 0, 2);
                else
                    dancerMove(dancers[i + 1], 0, 0, 2);
            }
        }

        function doGirlsRun(floor, dancers) {
            for (let i = 0; i < 12; i += 2) {
                if (dancers[i].isBoy == dancers[i + 1].isBoy)
                    throw "Same sex next to each other";

                swapPos(dancers[i], dancers[i + 1]);
                if (dancers[i].isBoy)
                    dancerMove(dancers[i + 1], 0, 0, 2);
                else
                    dancerMove(dancers[i], 0, 0, 2);
            }
        }

        function doStepToAWave(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                dancerMove(box[0], 1, -2, 0);
                dancerMove(box[1], 1, 0, 0);
                dancerMove(box[2], 1, 0, 0);
                dancerMove(box[3], 1, -2, 0);
            }
        }

        function doTradeBy(floor, dancers) {
            // Needed to avoid center boxes working 
            if (!dancerFacingAwayFromCenter(dancers[0]) || !(dancers.length == 12 || dancers.length == 8))
                throw "Not a Trade-By formation";

            trade(dancers[0], dancers[1]);
            // middle people pass thru
            for (let i = 2; i < dancers.length - 2; i++)
                dancerMove(dancers[i], 2, 0, 0);
            trade(dancers[dancers.length - 2], dancers[dancers.length - 1]);
        }

        function doBendTheLine(floor, dancers) {
            let lineLen = dancersLineLen(dancers);
            if (lineLen == 4) {
                for (let line of dancersGetLinesOf4(dancers)) {
                    // this is -1 for left handed waves, 1 for right handed
                    let left = (line[0].rotation == 0 || line[0].rotation == 3) ? 1 : -1;

                    for (let end of [line[0], line[3]])
                        dancerMove(end, 1, 2 * left, -left);
                    for (let center of [line[1], line[2]])
                        dancerMove(center, -1, 0, -left);
                }
                floor.sweepCCW = -1; // only for 2 faced, but that is the only kind possible here  TODO handle left handed
            }
            else if (lineLen == 6) {
                // group them into groups of 3, in a box, box3 is the box of the groups of 3
                // boxes are in the order
                //  2 3 
                //  0 1
                for (let box3 = 0; box3 < 4; box3++) {
                    // we iterate over the group from the center of the line (indexBase) out (idxDir)
                    let idxDir = box3 % 2 * 2 - 1                          // -1 on  0,2        1 on  1,3
                    let idxBase = 2 + 6 * Math.floor(box3 / 2) + box3 % 2    // yields 0,1,2,3  -> 2, 3, 8, 9 (center box)

                    let rotation = (1 <= box3 && box3 <= 2) ? -1 : 1;   //  1 on 0,3        -1 on  1,2
                    let dir = -rotation;                                 // -1 on 0,3         1 on  1,2
                    for (let i = 0; i < 3; i++) {
                        let dancer = dancers[idxBase + i * idxDir];
                        if (!dancerFacingAwayFromCenter(dancer))
                            throw "Dancers must be facing out";
                        dancerMove(dancer, 2 * i, 2 * i * dir, rotation);
                    }
                }
            }
            else
                throw "Formation wrong for bend the line.";
        }

        function doTagTheLine(floor, dancers) {
            let lineLen = dancersLineLen(dancers);
            // We don't implement tag the line for lines of 4 although we could.
            // it would mean adding lines of 3 as a legal configuration, and it does
            // not seem worth it right now
            if (lineLen == 6) {
                let facingSides = dancerIsFacingSides(dancers[0]);
                for (let i = 0; i < dancers.length; i++) {
                    let quadrant = Math.floor(i / 3);
                    let rotation = (quadrant % 2 == 0) ? 3 : 1;
                    if (facingSides)
                        --rotation;
                    dancers[i].rotation = rotation;         // Face in to the center  
                    dancerMove(dancers[i], 6, 0, 0);        // move 6 positions in the new direction
                }
            }
            else
                throw "Formation wrong for tag the line.";
        }


        function doTouchAQuarter(floor, dancers) {
            for (let dancer of dancers) {
                dancerMove(dancer, 2, 0, -1);
            }
        }

        function doStretchFerrisWheel(floor, dancers) {
            _doWheelFamily(floor, dancers, 5);
        }
        function doFerrisWheel(floor, dancers) {
            _doWheelFamily(floor, dancers, 3);
        }
        function doWheelAndDeal(floor, dancers) {

            // wheel and deal from lines of 6 facing out does not work as two groups of 3, 
            // but will work as a lef, right and a center couple (centers do a partner trade)  
            let lines = dancersLineLen(dancers);
            if (lines == 6 && dancers.length == 12) {
                for (let dancer of dancers) {
                    if (!dancerFacingAwayFromCenter(dancer))
                        throw "Dancers must be facing out";
                }
                for (let line = 0; line < 2; line++) {
                    let lineBase = line * 11;
                    let dir = (lineBase == 0) ? 1 : -1;
                    dancerMove(dancers[lineBase + 0 * dir], 2, -6, 2);
                    dancerMove(dancers[lineBase + 1 * dir], 2, -2, 2);
                    dancerMove(dancers[lineBase + 2 * dir], 0, -2, 2);
                    dancerMove(dancers[lineBase + 3 * dir], 0, 2, 2);
                    dancerMove(dancers[lineBase + 4 * dir], 4, 2, 2);
                    dancerMove(dancers[lineBase + 5 * dir], 4, 6, 2);
                }
            }
            else
                _doWheelFamily(floor, dancers, 1);
        }

        function doFirstLeftNextRight(floor, dancers) {
            // FirstLeftNextRight from completed triple pass thru sort of inverts a Wheel and Deal
            // We day that the first two couples do what you expect, the last partner trades.  
            let lines = dancersLineLen(dancers);
            if (lines == 2 && dancers.length == 12) {
                for (let dancer of dancers) {
                    if (!dancerFacingAwayFromCenter(dancer))
                        throw "Dancers must be facing out";
                }
                for (let line = 0; line < 2; line++) {
                    let lineBase = line * 11;
                    let dir = (lineBase == 0) ? 1 : -1;
                    dancerMove(dancers[lineBase + 0 * dir], -4, -6, 2);
                    dancerMove(dancers[lineBase + 1 * dir], -4, -2, 2);
                    dancerMove(dancers[lineBase + 2 * dir], -2, 2, 2);
                    dancerMove(dancers[lineBase + 3 * dir], -2, 6, 2);
                    dancerMove(dancers[lineBase + 4 * dir], 0, -2, 2);
                    dancerMove(dancers[lineBase + 5 * dir], 0, 2, 2);
                }
            }
        }

        // Handles Wheel+Deal (stretch=1), Ferris Wheel(stretch=3) and Stretch Ferris Wheel (stretch=5)
        function _doWheelFamily(floor, dancers, stretch) {
            let lines = dancersGetLinesOf4(dancers)
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                let dancerStretch = stretch;
                if (stretch == 5 && i == 1)        // For stretch ferris wheel, the middle group is not stretched.
                    dancerStretch = 3;

                for (let end of [line[0], line[3]]) {
                    if (floorIsFacingOut(floor, end))
                        dancerMove(end, 1, 4, 2);
                    else
                        dancerMove(end, dancerStretch, 4, 2);
                }
                for (let center of [line[1], line[2]]) {
                    if (floorIsFacingOut(floor, center))
                        dancerMove(center, 1, 0, 2);
                    else
                        dancerMove(center, dancerStretch, 0, 2);
                }
            }
            floor.sweepCCW = -1;        // only for centers
        }

        function doZoom(floor, dancers) {
            // these are arranged in twos up the central column
            for (let i = 0; i < dancers.length; i++) {
                if (4 <= i && i < 8)                  // Very Centers roll back
                    dancerMove(dancers[i], -4, 0, 0);
                else
                    dancerMove(dancers[i], 2, 0, 0);  // Otherwise move forward
            }
        }

        function doTriplePassThru(floor, dancers) {
            // these are arranged in twos up the central column
            for (let dancer of dancers)
                dancerMove(dancer, 6, 0, 0);
        }

        function doCloverleaf(floor, dancers) {
            // group them into groups of 3, in a box, box3 is the box of the groups of 3
            // boxes are in the order
            //  2 3 
            //  0 1
            for (let box3 = 0; box3 < 4; box3++) {
                // we iterate over the group from the center of the line (indexBase) out (idxDir)
                let idxDir = 2 * Math.floor(box3 / 2) - 1;         // -1 for 0, 1    1 for 1, 2
                let idxBase = 4 + box3;                                // iterates over the very center box
                let rotation = (box3 == 0 || box3 == 3) ? 1 : -1
                let dir = rotation;
                for (let i = 0; i < 3; i++)
                    dancerMove(dancers[idxBase + 2 * idxDir * i], -2 * i, (4 - 2 * i) * dir, rotation);
            }
        }

        function doCentersIn(floor, dancers) {
            let lineLen = dancersLineLen(dancers);
            if (lineLen != 2) // column-like
                throw "Bad Formation for centers in";

            // group them into groups of 3, in a box, box3 is the box of the groups of 3
            // boxes are in the order
            //  2 3 
            //  0 1
            for (let box3 = 0; box3 < 4; box3++) {
                // we iterate over the group from the center of the line (indexBase) out (idxDir)
                let idxDir = 2 * Math.floor(box3 / 2) - 1;             // -1 for 0, 1    1 for 1, 2
                let idxBase = 4 + box3;                                // iterates over the very center box
                let dir = (box3 == 0 || box3 == 3) ? 1 : -1
                for (let i = 0; i < 3; i++) {
                    let dancer = dancers[idxBase + 2 * idxDir * i];
                    if (!dancerFacingAwayFromCenter(dancer))
                        throw "Dancers must all be facing out";
                    dancerMove(dancer, -2 * i, 2 * i * dir, 0);
                }
            }
        }

        function doBoxTheGnat(floor, dancers) {
            for (let dancer of dancers) {
                if (floorIsFacingOut(floor, dancer))
                    throw "Dancers facing out can't box the gnat";
                dancerMove(dancer, 2, 0, 2);
            }
        }

        /*******************************/
        /* MainStream calls */

        function doHinge(floor, dancers, reverse) {
            let lineLen = dancersLineLen(dancers);

            // we have a line of 6 we need to expand it out before doing the hinge to make space
            if (lineLen == 6) {
                for (let dancer of dancers)
                    dancerScaleFacingCoordinate(dancer, 2);
            }

            for (let dancer of floor.dancers) {
                if (!reverse)  // Normal case hinge
                    dancerMove(dancer, 1, 1, -1);
                else           // This is cast off 3/4
                    dancerMove(dancer, -1, 1, 1);
            }

            // if we started with 3 lines of 4 we end up with two lines of 6, contract it down
            if (lineLen == 4) {
                for (let dancer of dancers)
                    dancerScaleFacingCoordinate(dancer, 0.5);
            }
        }

        function doPassToTheCenter(floor, dancers) {
            // this is needed to avoid allowing on lines facing in
            let lineLen = dancersLineLen(dancers);
            if (lineLen != 2 || !(dancers.length == 12 || dancers.length == 8))
                throw "Formation Wrong for Pass To The Center";

            // everyone passes through
            for (let dancer of dancers)
                dancerMove(dancer, 2, 0, 0);

            // The ends need to partner trade 
            // remember you have to use the STARTING index 
            trade(dancers[2], dancers[3]);
            trade(dancers[dancers.length - 4], dancers[dancers.length - 3]);
        }

        function doRecycle(floor, dancers) {
            for (let line of dancersGetLinesOf4(dancers)) {
                for (let end of [line[0], line[3]])
                    dancerMove(end, 1, 4, 2)
                for (let center of [line[1], line[2]])
                    dancerMove(center, -1, 0, 0)
            }
            floor.sweepCCW = -1;
        }

        function doHalfTag(floor, dancers) {
            for (let line of dancersGetLinesOf4(dancers)) {
                for (let end of [line[0], line[3]])
                    dancerMove(end, 1, 2, -1)
                for (let center of [line[1], line[2]])
                    dancerMove(center, 1, 2, -1)
            }
        }

        function doDixieStyle(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                for (let beau of [box[0], box[3]])
                    dancerMove(beau, 0, 1, 1);
                for (let belle of [box[1], box[2]])
                    dancerMove(belle, 4, -1, 1);
            }
        }

        function doWalkAndDodge(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                for (let beau of [box[0], box[3]])
                    dancerMove(beau, 2, 0, 0);
                for (let belle of [box[1], box[2]])
                    dancerMove(belle, 0, 2, 0);
            }
        }

        function doSpinChainThru(floor, dancers) {
            let lineLen = dancersLineLen(dancers);
            if (dancers.length != 12 || lineLen != 4 || !dancersIsFacingOpposite(dancers[0], dancers[1]))
                throw "Formation Wrong for Spin Chain Thru";

            // everyone trades. 
            for (let i = 0; i < dancers.length; i += 2)
                trade(dancers[i], dancers[i + 1]);

            // centers of central wave trade
            trade(dancers[4], dancers[11]);
            trade(dancers[0], dancers[7]);

            // cast off 3/4 is like another trade
            trade(dancers[0], dancers[11]);
            trade(dancers[3], dancers[7]);
            trade(dancers[4], dancers[8]);
        }

        function doCastOff3Quarters(floor, dancers) {

            // We are in waves
            if (dancersIsFacingOpposite(dancers[0], dancers[1])) {
                doHinge(floor, dancers, -1);    // Then it is a reverse hinge. 
                return;
            }
            let lineLen = dancersLineLen(dancers);
            // we have a line of 6 we need to expand it out before doing the hinge to make space
            if (lineLen == 6) {
                // we only support lines facing out 
                if (!dancerFacingAwayFromCenter(dancers[0]))
                    throw "Formation Wrong for Cast off 3/4";
                // has the same effect as a bend the line.  
                doBendTheLine(floor, dancers);
            }
            else if (lineLen == 4) {
                // two faced lines 
                for (let line of dancersGetLinesOf4(dancers)) {
                    for (let end of [line[0], line[3]])
                        dancerMove(end, 1, 2, -1);
                    for (let center of [line[1], line[2]])
                        dancerMove(center, -1, 0, -1);
                }
            }
            else
                throw "Formation Wrong for Cast off 3/4";
        }
        /********************************************************************/
        // END OF SQUARE DANCE CALLS
        /********************************************************************/

        /********************************************************************/
        // GUI Drawing support

        // puts the origin in the center and makes y grow up not down
        // Thus it acts like how you would set up x,y in math class. 
        function setOriginInCenter(canvas, canvasContext) {
            let centerX = canvas.width / 2;
            let centerY = canvas.height / 2;

            canvasContext.translate(centerX, centerY);
            canvasContext.scale(1, -1);
        }

        // the main method for drawing the floor.
        function floorDraw(floor, canvas) {
            const canvasContext = canvas.getContext('2d');

            canvasContext.clearRect(0, 0, canvas.width, canvas.height);

            // number of pixels between dancer position grid
            // for width == 500 -> gridSize == 40
            const gridSize = canvas.width / 12.5;

            // Draw a grid of dots
            setOriginInCenter(canvas, canvasContext);
            canvasContext.fillStyle = "black";
            for (let x = -6; x <= 6; x++) {
                for (let y = -6; y <= 6; y++) {
                    canvasContext.beginPath();
                    canvasContext.arc(x * gridSize, y * gridSize, gridSize / 20, 0, 2 * Math.PI);
                    canvasContext.fill();
                }
            }
            // draw a cross on the origin
            canvasContext.beginPath();
            canvasContext.moveTo(gridSize, 0);
            canvasContext.lineTo(-gridSize, 0);
            canvasContext.moveTo(0, gridSize);
            canvasContext.lineTo(0, -gridSize);
            canvasContext.stroke();

            if (floor === undefined)
                return;

            canvasContext.setTransform(1, 0, 0, 1, 0, 0);

            // draw Dancers
            for (let dancer of floor.dancers) {
                dancerDraw(dancer, canvas, canvasContext, gridSize)
            }

            canvasContext.setTransform(1, 0, 0, 1, 0, 0);
        }

        function dancerGetColor(dancer) {
            if (g_couplesIdentified)
                return COLORS[dancer.number - 1];

            // have we picked some random colors?
            if (!g_dancerColorsBoys) {

                // take the list of colors, make a copy and shuffle it
                let randomColor = COLORS.slice();
                for (let i = 0; i < 64; i++) {
                    let randIdx1 = Math.floor(Math.random() * COLORS.length);
                    let randIdx2 = Math.floor(Math.random() * COLORS.length);
                    // swap
                    let temp = randomColor[randIdx1];
                    randomColor[randIdx1] = randomColor[randIdx2];
                    randomColor[randIdx2] = temp;
                }
                g_dancerColorsBoys = randomColor.slice(0, 6);
                g_dancerColorsGirls = randomColor.slice(6, 12);
            }

            if (dancer.isBoy)
                return g_dancerColorsBoys[dancer.number - 1];
            else
                return g_dancerColorsGirls[dancer.number - 1];
        }

        function dancerDraw(dancer, canvas, canvasContext, gridSize) {
            setOriginInCenter(canvas, canvasContext);

            canvasContext.translate(dancer.gridX * gridSize, dancer.gridY * gridSize);

            canvasContext.rotate(Math.PI / 2.0 * dancer.rotation);

            canvasContext.beginPath();
            canvasContext.fillStyle = dancerGetColor(dancer);

            // draw bulge
            canvasContext.arc(0, 0.45 * gridSize, 0.3 * gridSize, 0, 2 * Math.PI);
            canvasContext.fill();

            // draw boy or girl
            canvasContext.beginPath();
            if (dancer.isBoy)
                canvasContext.rect(-0.45 * gridSize, -0.45 * gridSize, 0.9 * gridSize, 0.9 * gridSize);
            else
                canvasContext.arc(0, 0, 0.52 * gridSize, 0, 2 * Math.PI);
            canvasContext.fill();

            // draw the couple number (if we want couple numbers)
            if (g_couplesIdentified) {
                canvasContext.rotate(-Math.PI / 2.0 * dancer.rotation)
                canvasContext.scale(1, -1);
                canvasContext.font = (gridSize / 2) + "px Arial";
                canvasContext.fillStyle = "black";
                canvasContext.fillText(dancer.number, -gridSize * 0.15, gridSize * 0.2);
            }

            canvasContext.setTransform(1, 0, 0, 1, 0, 0);
        }

        /********************************************************************/
        // logic for handling GUI callbacks 

        // called when textbox changes (someone hits enter or paste in it)
        function textBoxOnChange(event) {
            console.log("GUI callback textBoxOnChange", event);
            let textBox = event.currentTarget;
            console.assert(textBox.nodeName === "INPUT");   // it is a textBox. 
            let call = textBox.value;
            textBox.value = "";
            onCommand(call);
        }

        // called when you click on list item in g_callHistory
        function callHistoryOnClick(event, isDouble) {
            console.log("GUI callback callHistoryOnClick", event);
            let listItem = event.currentTarget;
            console.assert(listItem.nodeName === "LI");      // it is a list item  
            let idx = listItem["data-index"];
            console.assert(idx !== undefined);
            if (isDouble)
                g_callListSavedIdx = idx;
            else
                g_callListSelectedItemIdx = idx;
            syncGUIToModel()
        }

        // called when you click on list item in g_callHistory
        function callHistoryOnDblClick(event) {
            callHistoryOnClick(event, true);
        }

        /*****************************/
        function onKeyDown(event) {
            console.log("GUI callback callHistoryOnClick", event);
            tone(0, 0);  // ensure that audio is initialized.    

            if (event.ctrlKey) {
                if (event.key == "s") {
                    g_callListSavedIdx = g_callListSelectedItemIdx;
                    syncGUIToModel();
                    event.preventDefault();   // avoid browser's save functionality
                    return false;
                }
                if (event.key == "z") {
                    onCommand("undo");
                    return false;
                }
                if (event.key == "i") {
                    onCommand("id");
                    return false;
                }
                if (event.key == "r") {
                    onCommand("reset");
                    event.preventDefault();   // avoid browser's reset functionality
                    return false;
                }
            }

            if (0 < g_callHistory.length) {
                if (event.key == "ArrowUp")
                    g_callListSelectedItemIdx = Math.max(0, g_callListSelectedItemIdx - 1);
                else if (event.key == "ArrowDown")
                    g_callListSelectedItemIdx = Math.min(g_callHistory.length - 1, g_callListSelectedItemIdx + 1);
                else if (event.key == "ArrowRight") // End key
                    g_callListSelectedItemIdx = g_callHistory.length - 1;
                else if (event.key == "ArrowLeft") // Home key
                    g_callListSelectedItemIdx = 0;
                else
                    return true;
                syncGUIToModel();
                return false;
            }
            return true;
        }

        // called from either the GUI buttons or by user typing a command.  
        function onCommand(command) {
            console.log("onCommand", command);

            while (true) {
                let match = command.toLowerCase().match(/^(([hsbgcev]) )?(\S+)\s*(.*)$/);
                if (!match)
                    break;

                let designator = match[2];
                let call = match[3];
                if (call.endsWith(";"))     // remove optional ; separator
                    call = call.slice(0, call.length - 1);
                command = match[4];
                let fullCall = call;
                if (designator)
                    fullCall = designator + " " + call;

                if (checkForCommand(call))
                    continue;

                // We always get the last end floor, we don't look at the selected position.  
                let startFloor = getEndFloor(g_callHistory, g_callHistory.length - 1);
                let floor = floorDeepCopy(startFloor);

                // transform the floor with a square dance call.  
                if (!doCall(floor, call, designator, fullCall))
                    break;

                // remember the results in the call History.  
                g_callHistory.push({ startFloor: startFloor, call: fullCall, endFloor: floor });
            }
            // always move the selection point to the end of the list. 
            g_callListSelectedItemIdx = g_callHistory.length - 1;
            syncGUIToModel();
        }

        function checkForCommand(command) {

            // This is just to make testing easy.   Users don't use the command.  
            if (command == "tst") {
                doTest();
                return true;
            }
            if (command == "reset" || command == "r") {
                g_lastCallHistory = g_callHistory;
                g_callHistory = [];
                g_callListSelectedItemIdx = -1;
                g_callListSavedIdx = -1;
                g_messageSpan.innerHTML = "Reset complete.";
                return true
            }
            if (command == "undo" || command == "u") {
                if (0 < g_callHistory.length) {
                    let prev = g_callHistory.pop();
                    g_messageSpan.innerHTML = "Undid: <strong>" + prev.call + "</strong>";

                    if (0 < g_callHistory.length) {
                        let prevHistory = g_callHistory[g_callHistory.length - 1];
                        g_messageSpan.innerHTML += " last call now: <strong>" + prevHistory.call + "</strong>";
                    }
                }
                else if (g_lastCallHistory) {
                    g_callHistory = g_lastCallHistory;
                } else
                    logError("Nothing to undo.");
                return true;
            }
            if (command == "id") {
                g_couplesIdentified = !g_couplesIdentified;
                // This lets you peek, if you are at a reset state, then choose new dancer colors too.  
                if (g_callHistory.length == 0) {
                    g_dancerColorsBoys = undefined;
                    g_dancerColorsGirls = undefined;
                }
                return true;
            }
            return false;
        }

        // Given 'call' (like rtl, sq4 ...) and a designator (e.g. h s c e v ...) 
        // actually update the floor (and the GUI) to execute the call.  
        function doCall(floor, call, designator, fullCall) {
            // The full call includes the designator, we use it when showing the call to the user.  
            console.log("Doing call", fullCall);

            // most calls do not have flow, so reset it here to create a default
            // don't reset it for sweep a quarter itself since we need that 
            // flow information to actually do the call and don't want to destroy it.   
            if (call != "saq")
                floor.sweepCCW = 0;                // 0 means no sweep  

            try {
                // Fetch the javaScript function that does the call
                let callFtn = CALL_TO_FTN[call];
                if (!callFtn)
                    throw "Unknown Call '" + call + "'";

                // parse the designators to determine what dancers actually move.  
                let dancers = floorGetDancers(floor, designator);
                dancersMoveDancersToGrid(dancers, designator);

                // and call the function.   
                callFtn(floor, dancers);

                // See if the call did something illegal.
                let formationError = floorFindError(floor, designator, callFtn);
                if (formationError) {
                    console.log("Validating call failed, formation error: " + formationError);
                    // this is only here to make debugging easier (you can see the formations)
                    syncGUIToModel(floor, getEndFloor(g_callHistory, g_callHistory.length - 1));
                    throw "Error: Bad formation for '" + call + "'" + "'";
                }
                floor.isResolved = floorIsResolved(floor);
                if (floor.isResolved)
                    chirp();
            } catch (err) {
                logError("Error Executing Call: " + err);
                return false;
            }

            // update other GUI state after a successful model update
            g_messageSpan.innerHTML = "Finished Call: " + fullCall;
            return true;
        }

        function logError(message) {
            beep();
            g_messageSpan.innerHTML = "<strong>" + message + "</strong>";
        }

        function getEndFloor(callHistory, curIndex) {
            console.assert(-1 <= curIndex && curIndex < callHistory.length);

            if (curIndex < 0)       // length is 0.  
                return floorReset();
            return callHistory[curIndex].endFloor;
        }

        function getStartFloor(callHistory, curIndex) {
            console.assert(-1 <= curIndex && curIndex < callHistory.length);

            if (curIndex < 0)       // length is 0.  
                return undefined
            return callHistory[curIndex].startFloor;
        }

        // called when we want to make sure that the GUI represents the model (after we changed the model)
        // NOTE most of the time you DON'T pass endFloor, startfloor.  It is only for debugging when you do
        function syncGUIToModel(endFloor, startFloor) {
            if (!endFloor)
                endFloor = getEndFloor(g_callHistory, g_callListSelectedItemIdx);

            // If we ar resolved turn on the label that says so.  
            g_resolvedsSpan.style.visibility = endFloor.isResolved ? "visible" : "hidden";

            g_identifyButton.innerText = g_couplesIdentified ? "hide" : "identify";

            floorDraw(endFloor, g_mainCanvas);

            if (!startFloor)
                startFloor = getStartFloor(g_callHistory, g_callListSelectedItemIdx);
            floorDraw(startFloor, g_prevCanvas);

            let savedFloor = undefined;
            let savedCallNum = "";
            if (0 <= g_callListSavedIdx) {
                savedFloor = getEndFloor(g_callHistory, g_callListSavedIdx);
                savedCallNum = g_callListSavedIdx + 1;
            }
            g_savedCallNumSpan.innerText = savedCallNum;
            floorDraw(savedFloor, g_savedCanvas);

            // Update the history list g_callListSelectedItem
            g_callListOrderedList.replaceChildren();
            for (let i = 0; i < g_callHistory.length; i++) {
                let li = document.createElement("li");
                li["data-index"] = i;                   // remember where I am in the list 
                li.innerText = g_callHistory[i].call;
                li.addEventListener("click", callHistoryOnClick);
                li.addEventListener("dblclick", callHistoryOnDblClick);
                g_callListOrderedList.appendChild(li);
            }
            if (0 <= g_callListSavedIdx) {
                let saved = g_callListOrderedList.children[g_callListSavedIdx];
                saved.style.backgroundColor = "#3BAB39";    // a green 
            }
            if (0 <= g_callListSelectedItemIdx) {
                let selected = g_callListOrderedList.children[g_callListSelectedItemIdx];
                selected.style.backgroundColor = "#4498E1";  // a light blue
                selected.scrollIntoView({ block: "nearest" });
            }
            g_callInput.focus();    // put focus here. 
        }

        // used to initialize the CALL_TO_FTN table. 
        function getCallFtns() {
            let ret = {};
            ret["home"] = doHome;
            ret["al"] = doAllemandeLeft;
            ret["pt"] = doPassThru;
            ret["p1/2"] = doPromHalf;
            ret["p12"] = doPromHalf;
            ret["srt"] = doStarThru;
            ret["sl"] = doStarThru;
            ret["rlt"] = doRightAndLeftThru;
            ret["vl"] = doVeerLeft;
            ret["sq4"] = doSquareThru4;
            ret["sq2"] = doSquareThru2;
            ret["lr"] = doLeadRight;
            ret["ptd"] = doTrade;
            ret["st"] = doSwingThru;
            ret["ex"] = doExtend;
            ret["btl"] = doBendTheLine;
            ret["ttl"] = doTagTheLine;
            ret["tb"] = doTradeBy;
            ret["stw"] = doStepToAWave;
            ret["br"] = doBoysRun;
            ret["gr"] = doGirlsRun;
            ret["sb"] = doTrade;;
            ret["td"] = doTrade;;
            ret["sq3"] = doTrade;;
            ret["hs"] = doHalfSashay;
            ret["utb"] = doTurnBack;
            ret["cdtl"] = doChainDownTheLine;
            ret["pto"] = doPassTheOcean;
            ret["saq"] = doSweepAQuarter;
            ret["fl"] = doFlutterWheel;
            ret["rfl"] = doReverseFlutterWheel;
            ret["tq"] = doTouchAQuarter;
            ret["circ"] = doCirculate;
            ret["hinge"] = doHinge;
            ret["whd"] = doWheelAndDeal;
            ret["zoom"] = doZoom;
            ret["fw"] = doFerrisWheel;
            ret["sfw"] = doStretchFerrisWheel;
            ret["ptc"] = doPassToTheCenter;
            ret["rec"] = doRecycle;
            ret["ht"] = doHalfTag;
            ret["fi"] = doFaceIn;
            ret["dx"] = doDixieStyle;
            ret["wad"] = doWalkAndDodge;
            ret["cl"] = doCloverleaf;
            ret["btg"] = doBoxTheGnat;
            ret["tpt"] = doTriplePassThru;
            ret["sct"] = doSpinChainThru;
            ret["cast3"] = doCastOff3Quarters;
            ret["ci"] = doCentersIn;
            ret["flnr"] = doFirstLeftNextRight;
            return ret;
        }

        /********************************************************************/
        // support for sound (beeps)

        function beep() { tone(50, 440); }

        function chirp() { tone(20, 2000); }

        // tone(0,0) can be called to insure sound is set up
        // It must be done AFTER first user interaction AND
        // it takes a while (> 100 msec).  
        function tone(duration, frequency) {
            if (audioCtx === undefined)
                audioCtx = new window.AudioContext;
            if (duration == 0)
                return;
            let oscillator = audioCtx.createOscillator();
            let gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = frequency;
            // oscillator.type = "sine"; 

            oscillator.start();
            setTimeout(function () { oscillator.stop() }, duration);
        };
        let audioCtx;

        /********************************************************************/
        /********************************************************************/
        // TESTING    Called by the 'tst' command to allow quick unit testing
        function doTest() {
            // just run a long sequence that resolves and uses every call.   
            onCommand(
                "reset h pto ex st br cdtl pt btl tq circ circ circ br sq4 btl srt pt " +
                "tb srt dx e circ gr btl pto hinge td hinge rec saq srt vl sfw v pt c pt sl pt hs utb fl " +
                "rfl srt pt tb pt tb fl sq3 ptd vl sfw zoom zoom tpt cl zoom fi srt cl v pt c pt pt tb pt tb " +
                "pt tb tq wad ptd rfl srt ptc c sq3 srt pto st br ht sb br srt stw st br whd " +
                "lr ptd rlt saq vl fw c pt rlt hs btg rlt " +
                "srt ttl cl fi srt pt tb pt tb srt tq circ circ circ br rlt pt tb rlt vl sfw v sq3 c ptc v pt c pt rlt pt tb " +
                "stw sct circ br btl pto cast3 hinge cast3 br srt pt " +
                "c pt v pt ci ptd v rlt srt e td rlt pt tb " +
                "srt pt whd tpt flnr tq circ br vl sfw v fl v pt c ptc v pt c pt"
            );

            let endFloor = g_callHistory[g_callHistory.length - 1].endFloor;
            if (!endFloor.isResolved) {
                logError("TestError: test did not resolve the square");
                return;
            }

            if (!g_messageSpan.innerHTML.match(/error/i))
                g_messageSpan.innerHTML = "<strong>" + "Successful Testing.  Square should be resolved (corner boxes)." + "</strong>";
        }
    </script>
</body>

</html>