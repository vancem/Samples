<!doctype html>
<html>

<body>
    <!-- *********************************************************************** -->
    <p> This is a simple program that makes a ball bounce around in a box.</p>
    <ul>
        <li> Command: <input id=command type=text onchange="doCommandOnChange()"> </li>
        <li> Message: <span id=message></span> </li>
    </ul>
    <canvas id="canvas" tabindex="1" style="border:2px solid red" height="500" width="500"> </canvas>
    <p>
        <b>Call List:</b><br> 
        <span id=callList></span>
    </p>
    <script>
        /***********************************************************************/
        // Global variables 
        "use strict";

        // get GUI objects needed
        let canvas = document.getElementById('canvas');
        let canvasContext = canvas.getContext('2d');
        let commandTextbox = document.getElementById('command');
        let messageSpan = document.getElementById('message');
        let callListSpan = document.getElementById('callList');

        // Values for dancers based on their dancer number 
        const colors = ["red", "green", "cyan", "yellow", "violet", "blue" ];

        let commands = {};
        commands["st"] = doSwingThru;
        commands["sq4"] = doSquareThru4;
        commands["hsq4"] = doHeadsSquareThru4;
        commands["hpto"] = doHeadsPassTheOcean;
        commands["h pto"] = doHeadsPassTheOcean;
        commands["ex"] = doExtend;
        commands["h sq4"] = doHeadsSquareThru4;
        commands["home"] = doHome;
        commands["rlt"] = doRightAndLeftThru;
        commands["vl"] = doVeerLeft;
        commands["btl"] = doBendTheLine;
        commands["srt"] = doStarThru;
        commands["pt"] = doPassThru;
        commands["tb"] = doTradeBy;
        commands["stw"] = doStepToAWave;
        commands["br"] = doBoysRun;
        commands["ptd"] = doTrade;
        commands["sb"] = doTrade;;
        commands["sq3"] = doTrade;;
        commands["utb"] = doTurnBack;
        commands["cdtl"] = doChainDownTheLine;
        commands["pto"] = doPassTheOcean;
        commands["fl"] = doFlutterWheel;
        commands["rfl"] = doReverseFlutterWheel;
        commands["tq"] = doTouchAQuarter;
        commands["circ"] = doCirculate;
        commands["hinge"] = doHinge;
        commands["fw"] = doFerrisWheel;
        commands["cpt"] = doCentersPassThru;
        commands["csq3"] = doCentersSquareThru3;

        // Values for dancer.rotation
        const NORTH = 0;
        const WEST = 1;
        const SOUTH = 2;
        const EAST = 3;
        let floor = resetFloor();

        function doHinge(floor) {
            let srtDancers = sortForPartners(floor)
            for(let dancer of floor.dancers) {
                stepForward(dancer, 1);
                slideRight(dancer, 1);
                rotateCCW(dancer, -1);
            }
        }

        function doTouchAQuarter(floor) {
            for(let box of getBoxes(floor)) {
                swapPos(box[0], box[3]);
                swapPos(box[1], box[2]);
                for(let dancer of box)
                    rotateCCW(dancer, -1);
            }
        }

        function doFlutterWheel(floor) {
            for(let box of getBoxes(floor)) {
                swapPosAndDir(box[0], box[2]);
            }
        }

        function doReverseFlutterWheel(floor) {
            for(let box of getBoxes(floor)) {
                swapPosAndDir(box[1], box[3]);
            }
        }


        function doPassTheOcean(floor) {
            for(let box of getBoxes(floor)) 
                passTheOcean(box);
        }

        function doChainDownTheLine(floor) {
            for(let line of getLinesOf4(floor)) {
                for(let beau of [line[0], line[3]])  {
                    stepForward(beau);
                    slideRight(beau, 2);
                    rotateCCW(beau, -1);
                }
                
                for(let bell of [line[1], line[2]])  {
                    stepForward(bell);
                    slideRight(bell, 2);
                    rotateCCW(bell, 1);
                }
            }
        }

        function doCentersPassThru(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 6 && srtDancers[0].rotation == 3)  {

		srtDancers = sortForPartners(floor)
		for(let i = 2; i < 10; i++)
                    stepForward(srtDancers[i], 2);
	    }
	    else
		throw "Formation Wrong for Centers pass thru";
	}

        function doCentersSquareThru3(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 6 && srtDancers[0].rotation == 3)  {

		srtDancers = sortForPartners(floor)
		for(let i = 2; i < 10; i += 2)
                    trade(srtDancers[i], srtDancers[i+1]);
	    }
	    else 
		throw "Formation Wrong for Centers Square Thru 3";
	}

        function doFerrisWheel(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 3 && srtDancers[0].rotation == 1)  {

		// boys facing out of square
		for(let beau of [srtDancers[0], srtDancers[11]]) {
		    stepForward(beau)
		    slideRight(beau, 4);
		    rotateCCW(beau, 2);
		}
		// girls facing out of square
		for(let bell of [srtDancers[3], srtDancers[8]]) {
		    stepForward(bell)
		    rotateCCW(bell, 2);
		}

		// boys facing in
		for(let beau of [srtDancers[9], srtDancers[10], srtDancers[2], srtDancers[1], ]) {
		    stepForward(beau, 3)
		    slideRight(beau, 4);
		    rotateCCW(beau, 2);
		}
		// girls facing in
		for(let bell of [srtDancers[6], srtDancers[7], srtDancers[5], srtDancers[4]]) {
		    stepForward(bell, 3)
		    rotateCCW(bell, 2);
		}
                return;
            }
	    else 
		throw "Formation Wrong for Ferris Wheel";
        }

        function doBoysRun(floor) {
            let srtDancers = sortForPartners(floor)
            for(let i = 0; i < 12; i+=2) {
                swapPos(srtDancers[i], srtDancers[i+1]);
                if (srtDancers[i].isBoy)
                    rotateCCW(srtDancers[i], 2);
                else
                    rotateCCW(srtDancers[i+1], 2);
            }
        }

        function doTurnBack(floor) {
            for(let dancer of floor.dancers)
                rotateCCW(dancer, 2);
        }

        function sortForPartners(floor) {
            let srtDancers = floor.dancers.slice();
            if (isFacingHeads(srtDancers[0]))
                srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
            else 
                srtDancers.sort((a, b) => cmpOrder(a.gridX-b.gridX, b.gridY-a.gridY));
            return srtDancers;
        }

        function doTrade(floor) {
            let srtDancers = sortForPartners(floor)
            for(let i = 0; i < 12; i+=2)
                trade(srtDancers[i], srtDancers[i+1]);
        }

        function doSwingThru(floor) {
            for(let line of getLinesOf4(floor)) {
                // ends and centers trade
                swapPosAndDir(line[0], line[1]);
                swapPosAndDir(line[2], line[3]);

                // centers trade (note that we have to use the ORIGINAL indexes
                // to fetch people now in the center
                swapPosAndDir(line[0], line[3]);
            }
        }

        function doHome(floor) {
            resetFloor(floor);
        }

        function stepForward(dancer, delta = 1) {
            if (dancer.rotation == SOUTH || dancer.rotation == WEST)
                delta = -delta;

            if (dancer.rotation == NORTH || dancer.rotation == SOUTH)
                dancer.gridY += delta;
            else 
                dancer.gridX += delta;
        }

        function slideRight(dancer, delta = 1) {
            rotateCCW(dancer, -1);
            stepForward(dancer, delta);
            rotateCCW(dancer, 1);
        }


        function rotateCCW(dancer, numCCWQuarter) {
             if (numCCWQuarter < 0)
                 numCCWQuarter += 4;
             dancer.rotation = (dancer.rotation + numCCWQuarter) % 4;
        }

        function isSides(dancer) {
            return dancer.number == 3 || dancer.number == 6;
        }
        function isHeads(dancer) {
            return !isSides(dancer);
        }

        function isFacingHeads(dancer) {
            return dancer.rotation % 2 == 0;
        }
        function isFacingSides(dancer) {
            return dancer.rotation % 2 == 1;
        }

        function cmpOrder(val1, val2) {
            if (val1 != 0)
                return val1;
            return val2;
        }

        function horzLineLen(srtDancers, start = 0) {
            console.assert(srtDancers.length == 12);
            let gridY = srtDancers[start].gridY
            let ret = 1;
            for(let i = start+1; i < srtDancers.length; i++) {
                if (srtDancers[i].gridY != gridY)
                    break;
                ret++;
            }
            return ret;
        }

        function rotateBoxCW(box) {
            console.assert(box.length == 4);
            let temp = box[0];
            box[0] = box[3];
            box[3] = box[2];
            box[2] = box[1];
            box[1] = temp;
        }

        function passTheOcean(box) {
            for(let beau of [box[0], box[2]])  {
                stepForward(beau, 4);
                slideRight(beau, 1);
                rotateCCW(beau, -1);
            }
            
            for(let bell of [box[1], box[3]])  {
                stepForward(bell, 2);
                slideRight(bell, -1);
                rotateCCW(bell, 1);
            }
        }


        function trade(dancer1, dancer2) {
            swapPos(dancer1, dancer2)
            rotateCCW(dancer1, 2);
            rotateCCW(dancer2, 2);
        }
        
        // get boxes from the floor.  A box is an array that orders 
        // its elements like this
        //    3 2
        //    0 1
        // where the dancers are facing north or south (never east or west)
        function getBoxes(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));

            let ret;
            let needRotate;
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 6) {  
                // Assume 2 lines of 6 facing heads
                ret = [[srtDancers[0], srtDancers[1], srtDancers[7], srtDancers[6]],
                              [srtDancers[2], srtDancers[3], srtDancers[9], srtDancers[8]],
                           [srtDancers[4], srtDancers[5], srtDancers[11], srtDancers[10]] ];
                needRotate = isFacingSides(srtDancers[0]);  // In this case it is columns or triple box
            }
            else if (horzLen == 2 && horzLineLen(srtDancers, 2) == 2) {
                // Assume colums facing heads
                ret = [[srtDancers[0], srtDancers[1], srtDancers[3], srtDancers[2]],
                              [srtDancers[4], srtDancers[5], srtDancers[7], srtDancers[6]],
                           [srtDancers[8], srtDancers[9], srtDancers[11], srtDancers[10]]];
                needRotate = isFacingSides(srtDancers[0]); // 2 lines of 6
            }
            else 
                throw "Expected Boxes";

            if (needRotate) {
                for(let box of ret) 
                   rotateBoxCW(box)
            }
            return ret;
        }

        // returns dancers in 3 lines of 4.   First line is at the bottom
        function getLinesOf4(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));

            let ret;
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 4) {  // 3 horizontal lines of 4
                ret = [[srtDancers[0], srtDancers[1], srtDancers[2], srtDancers[3]],
                       [srtDancers[4], srtDancers[5], srtDancers[6], srtDancers[7]],
                       [srtDancers[8], srtDancers[9], srtDancers[10], srtDancers[11]] ];
            }
            else if (horzLen == 3) {
                ret = [[srtDancers[9], srtDancers[6], srtDancers[3], srtDancers[0]],
                       [srtDancers[10], srtDancers[7], srtDancers[4], srtDancers[1]],
                       [srtDancers[11], srtDancers[8], srtDancers[5], srtDancers[2]]];
            }
            else 
                throw "Expected 3 lines of 4";

            return ret;
        }


        function swapPosAndDir(dancer1, dancer2) {
            swapPos(dancer1, dancer2);

            let temp = dancer1.rotation;
            dancer1.rotation = dancer2.rotation;
            dancer2.rotation = temp;
        }

        function swapPos(dancer1, dancer2) {
            let temp = dancer1.gridX;
            dancer1.gridX = dancer2.gridX;
            dancer2.gridX = temp;

            temp = dancer1.gridY;
            dancer1.gridY = dancer2.gridY;
            dancer2.gridY = temp;
        }

        function moveHeadsInIfNecessary(floor) {
        
            for(let dancer of floor.dancers) 
                if (isHeads(dancer) && Math.abs(dancer.gridY) == 3)
                    stepForward(dancer, 2);
        }

        function doHeadsSquareThru4(floor) {

            moveHeadsInIfNecessary(floor);

            for(let dancer of floor.dancers) {
                if (isHeads(dancer))
                    rotateCCW(dancer, dancer.isBoy?1:-1);
            }
        }

        function doSquareThru4(floor) {
            for(let box of getBoxes(floor)) 
                squareThru4(box);
        }

        function squareThru4(box) {
            rotateCCW(box[0], 1);
            rotateCCW(box[1], -1);
            rotateCCW(box[2], 1);
            rotateCCW(box[3], -1);
        }

        function doHeadsPassTheOcean(floor) {
            moveHeadsInIfNecessary(floor);
            
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));

            passTheOcean([srtDancers[1], srtDancers[2], srtDancers[8], srtDancers[7]]);
            passTheOcean([srtDancers[3], srtDancers[4], srtDancers[10], srtDancers[9]]);
        }

        function doExtend(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));

            let horzLen = horzLineLen(srtDancers)
            let horzLen2 = horzLineLen(srtDancers, 2);
            if (horzLen == 2 && horzLen2 == 4) {
                srtDancers.sort((a, b) => cmpOrder(a.gridX-b.gridX, b.gridY-a.gridY));

                for(let i = 0; i < srtDancers.length; i++) { 
                    stepForward(srtDancers[i], (i <= 1 || 10 <= i) ? 1 : 2);
                    if (i == 0 || i == srtDancers.length-1)
                        slideRight(srtDancers[i], -2);
                }
            }
            else 
                throw "Expected QuarterTag";
        }

        function doRightAndLeftThru(floor) {
            for(let box of getBoxes(floor)) {
                swapPosAndDir(box[0], box[2]);
                swapPosAndDir(box[1], box[3]);
            }
        }

        function doCirculate(floor) {
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 3 && isFacingSides(srtDancers[0]))  {        // Three vertical lines
                let minX = srtDancers[0].gridX;
                let maxX = srtDancers[11].gridX;
                let delta = (maxX - minX) / 2;
                
                for(let dancer of srtDancers) {
                    let inc = (dancer.rotation == 1) ? -delta : delta;

                    if (dancer.gridX == minX  && dancer.rotation == 1 ||   // min heading left
                        dancer.gridX == maxX  && dancer.rotation == 3) {   // max heading right
                        rotateCCW(dancer, 2);
                        dancer.gridY = -dancer.gridY;
                    }
                    else
                        dancer.gridX += inc;
                }
            }
            else if (horzLen == 2 && isFacingHeads(srtDancers[0]))  {     // colums
                let minY = srtDancers[0].gridY;
                let maxY = srtDancers[11].gridY;
                let delta = (maxY - minY) / (12/horzLen - 1);
                
                for(let dancer of srtDancers) {
                    let inc = (dancer.rotation == 2) ? -delta : delta;

                    if (dancer.gridY == minY  && dancer.rotation == 2 ||   // min heading down
                        dancer.gridY == maxY  && dancer.rotation == 0) {   // max heading up
                        rotateCCW(dancer, 2);
                        dancer.gridX = -dancer.gridX;
                    }
                    else
                        dancer.gridY += inc;
                }
            }
            else 
                throw "Expected lines";        // TODO handle other cases
        }

        function doVeerLeft(floor) {
            for(let dancer of floor.dancers) {
                stepForward(dancer);
                slideRight(dancer, -2);
            }
        }

        function doStepToAWave(floor) {
            let boxes = getBoxes(floor);

            for(let dancer of floor.dancers) {
                stepForward(dancer);
            }

            for(let box of boxes) {
                slideRight(box[0], -2);
                slideRight(box[2], -2);
            }
        }

        function doStarThru(floor) {
            for(let box of getBoxes(floor)) {
                swapPos(box[0], box[3]);
                swapPos(box[1], box[2])
                
                for(let dancer of box) 
                    rotateCCW(dancer, dancer.isBoy?-1:1);
            }
        }

        function doPassThru(floor) {
            for(let box of getBoxes(floor)) {
                swapPos(box[0], box[3]);
                swapPos(box[1], box[2]);
            }
        }

        function doTradeBy(floor) {
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 2)  {
                srtDancers.sort((a, b) => cmpOrder(b.gridX-a.gridX, a.gridY-b.gridY));
            }
            else if (horzLen != 6)
                throw "Expected Trade By formation"
            
            trade(srtDancers[0], srtDancers[6]);

            swapPos(srtDancers[1], srtDancers[2]);
            swapPos(srtDancers[7], srtDancers[8]);

            swapPos(srtDancers[3], srtDancers[4]);
            swapPos(srtDancers[9], srtDancers[10]);

            trade(srtDancers[5], srtDancers[11]);
        }

        function doBendTheLine(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 3)  {        // Three vertical lines
                for(let line of getLinesOf4(floor)) {
                    for(let end of [line[0], line[3]]) {
                        stepForward(end)
                        slideRight(end, 1);         // TODO handle left handed two faced lines
                        rotateCCW(end, -1);
                        stepForward(end);
                    }
                    for(let center of [line[1], line[2]]) {
                        stepForward(center, -1)
                        slideRight(center, -1);
                        rotateCCW(center, -1);
                        stepForward(center);
                    }
                }
                return;
            }
            else if (horzLen == 6 && srtDancers[0].rotation == 2) { // facing out toward heads
                bendNormalizedLineOf6(srtDancers, 1);
            }
            else if (horzLen == 2 && srtDancers[0].rotation == 1) {            // facing out toward sides
                srtDancers.sort((a, b) => cmpOrder(a.gridX-b.gridX, b.gridY-a.gridY));
                bendNormalizedLineOf6(srtDancers, -1);
            }
            else 
                throw "Expected lines";
        }

        function bendNormalizedLineOf6(dancers, reflectBase) {
            let ctr = 0;
            for(let dancer of dancers) {
                let reflect = reflectBase * ((3 <= ctr && ctr < 9) ? -1 : 1);
                ctr++;

                let temp = dancer.gridX;
                dancer.gridX = dancer.gridY * reflect;
                dancer.gridY = temp * reflect;
                rotateCCW(dancer, reflectBase * reflect);
            }
        }

        function drawFloor(floor) {
            console.log("Entering drawFloor", floor);
        
            canvasContext.clearRect(0, 0, canvas.width, canvas.height);

            // Draw a grid of dots
            setOrginInCenter();
            canvasContext.fillStyle = "black";
            for(let x = -6; x <= 6; x++) {
                for(let y = -6; y <= 6; y++) {
                    canvasContext.beginPath();
                    canvasContext.arc(x * 40, y * 40, 2, 0, 2 * Math.PI); 
                    canvasContext.fill();        
                }
            }
                // draw a cross on the origin
            canvasContext.beginPath();
            canvasContext.moveTo(40, 0);
            canvasContext.lineTo(-40, 0);
            canvasContext.moveTo(0, 40);
            canvasContext.lineTo(0, -40);
            canvasContext.stroke();
            
            canvasContext.setTransform(1, 0, 0, 1, 0, 0);

               // draw Dancers
            for(let dancer of floor.dancers) {
                 drawDancer(dancer, floor)
            }

            canvasContext.setTransform(1, 0, 0, 1, 0, 0);
        }

        // puts the orgin in the center and makes y grow up not down
        function setOrginInCenter() {
            let centerX = canvas.width / 2;
            let centerY = canvas.height / 2;

            canvasContext.translate (centerX, centerY);
            canvasContext.scale(1, -1);
        }


        function drawDancer(dancer) {
            setOrginInCenter();

                // TODO scale 40 based on canvas size.  
            canvasContext.translate (dancer.gridX * 40 , dancer.gridY * 40);

            canvasContext.rotate(Math.PI / 2.0 * dancer.rotation)
            canvasContext.fillStyle = colors[dancer.number-1];

                // draw boy or girl
            if (dancer.isBoy) 
                canvasContext.fillRect(-15, -15, 30, 30);
            else  {
                canvasContext.beginPath();
                canvasContext.arc(0, 0, 16, 0, 2 * Math.PI); 
                canvasContext.fill();        
            }
                // draw bulge
            canvasContext.beginPath();
            canvasContext.arc(0, 15, 8, 0, 2 * Math.PI); 
            canvasContext.fill();        
        
                // draw the couple number
            canvasContext.rotate(-Math.PI / 2.0 * dancer.rotation)
            canvasContext.scale(1, -1);
            canvasContext.font = "20px Arial";
            canvasContext.fillStyle = "black";
            canvasContext.fillText(dancer.number, -6, 8);

            canvasContext.setTransform(1, 0, 0, 1, 0, 0);
        }

        function resetFloor(floor) {
            if (floor == undefined)
                 floor = {};
            floor.dancers = [];
            makeCouple(floor.dancers, 1, -3, -3, NORTH);
            makeCouple(floor.dancers, 2, 1, -3,  NORTH);
            makeCouple(floor.dancers, 3, 5, -1, WEST);
            makeCouple(floor.dancers, 4, 3, 3, SOUTH);
            makeCouple(floor.dancers, 5, -1, 3, SOUTH);
            makeCouple(floor.dancers, 6, -5, 1, EAST);

            return floor;
        }

        function makeCouple(dancers, number, gridX, gridY, rotation) {

            // Create the boy dancer
            dancers.push({ isBoy:true, number:number, rotation:rotation, gridX:gridX, gridY:gridY });

            // create the girl dancer
            let girl = { isBoy:false, number:number, rotation:rotation, gridX:gridX, gridY:gridY };
            slideRight(girl, 2);

            dancers.push(girl);
        }

        function logError(message) {
            beep();
            messageSpan.innerHTML = message;
        }

        function doCall(call) {
            console.log("doCall", call);
	    if (call == "reset") {
		callListSpan.innerHTML = "";
                resetFloor(floor);
		drawFloor(floor);
		messageSpan.innerHTML = "Reset!";
		return;
	    }

            let cmdFtn = commands[call];
            if (cmdFtn == undefined) {
                if (call.indexOf(" ")) {
                    for(let subCall of call.split(/\s+/)) {
                        if (!doCall(subCall))
                            return false;
                    }
                    return true;
                }
                else {
                    logError("Unrecognised Call: " + call);
                    return false;
                }
            }

            try {
                cmdFtn(floor);
            } catch(err) {
                 logError("Error Executing Call: " + err);
                 return false;
            }
            drawFloor(floor);
            messageSpan.innerHTML = "Finished Call: " + call;
            callListSpan.innerHTML += call + "<br>";
            return true;
        }
        
        function doCommandOnChange() {
            let call = commandTextbox.value;        
            commandTextbox.value = "";
            doCall(call)
        }

        function beep() { tone(50, 440); }

        function tone(duration, frequency) {
            if (audioCtx === undefined)
                audioCtx = new window.AudioContext;
            let oscillator = audioCtx.createOscillator();
            let gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = frequency;
            // oscillator.type = "sine"; 

            oscillator.start();
            setTimeout(function () { oscillator.stop() }, duration);
        };
        let audioCtx;

        // draw the initial floor
        drawFloor(floor);
    </script>
</body>

</html>
