<!doctype html>
<html>

<body>
    <!-- *********************************************************************** -->
    <!-- The body section describes the visual layout of the page -->

    <p> This is a program that simulates square dance calls for a 6 couple rectangle.
        This was inspired by the 
        <a href="https://www.tamtwirlers.org/taminations/#?main=SEQUENCER&formation=Squared%20Set" target="_blank">
        Taminations sequencer</a>.  You can get the definitions for Mainstream square dance calls at 
        <a href="https://www.tamtwirlers.org/taminations/#?level=Basic%20and%20Mainstream&main=LEVELS&detail=CALLS" target="_blank">
        Taminations mainstream list</a>.
    </p> <p>
        The error handling is rudimentary at best. It has also only been
        tested in 'simple' cases, but it does seem to work if you stick to 
        valid call sequences.   
    <ul>
        <li> Calls are given very short abbreviations that are mostly the first letter of 
             each word in the call (exeptions below).  Couple circulate is just circulate.
        <li> h=heads, c=centers, e=ends, fl=flutterwheel srt=star thru,
             st=swing thru, td=trade, sl=slide thru</li>
        <li> Calls Available: <span id=allCalls></span> </li>

        <li> Must explicitly call step to a wave (stw) from facing couples.
        <li> You can paste multiple commands (sep by space) into textbox.
        
    </ul> <ul>
        <li> Type Calls here: <input id=command type=text onchange="doCommandOnChange()"> 
             <button onClick="doCall('reset')">reset</button>
             <button onClick="doCall('undo')">undo</button>
        </li>
        <li> Message: <span id=message></span> </li>
    </ul>
    <div style="display:flex"> 
        <canvas id=main tabindex=1 style="border:2px solid red" height=500 width=500> </canvas>
        <div style="background-color:lightgray;height:500px;overflow-y:scroll"> 
            <p style="margin:10px">
                <b>Call History</b><br> 
                <span id=callList></span>
            </p>
        </div> 
        <div style="background-color:#dfedf5"> 
            <div style="text-align:center;margin:10px;font-size:x-large;font-weight:bold">Previous Dancer Positions</div>
            <canvas id=prev style="border:2px solid red;background-color:lightgray;vertical-align:bottom" height=400 width=400> </canvas>
        </div>
    </div> 

    <!-- *************************** END OF HTML ******************************* -->

    <script>
        "use strict";                // do extra error checking at load time

        /***********************************************************************/
        // STARTUP code.   This initializes global constants, GUI constants, 
        // and the model for the program (the dance floor)

        // Global CONSTANTS 
        // get GUI objects needed
        const mainCanvas = document.getElementById('main');
        const prevCanvas = document.getElementById('prev');

        const commandTextbox = document.getElementById('command');
        const messageSpan = document.getElementById('message');
        const callListSpan = document.getElementById('callList');
        const allCallsSpan = document.getElementById('allCalls');

        // Values for dancers based on their dancer number 
        const colors = ["red", "green", "cyan", "yellow", "violet", "blue" ];

        // Values for dancer.rotation.  These work like map directions
        const NORTH = 0;
        const WEST = 1;
        const SOUTH = 2;
        const EAST = 3;

        // commands maps call names to the method that performs it
        // used in doCall
        const commands = {};
        commands["h pto"] = doHeadsPassTheOcean;
        commands["h lr"] = doHeadsLeadRight;
        commands["h pto"] = doHeadsPassTheOcean;
        commands["h sq4"] = doHeadsSquareThru4;
        commands["c circ"] = doCentersCirculate;
        commands["e circ"] = doEndsCirculate;
        commands["c pt"] = doCentersPassThru;
        commands["c sq3"] = doCentersSquareThru3;
        commands["c td"] = doCentersTrade;
        commands["st"] = doSwingThru;
        commands["sq4"] = doSquareThru4;
        commands["ex"] = doExtend;
        commands["home"] = doHome;
        commands["rlt"] = doRightAndLeftThru;
        commands["vl"] = doVeerLeft;
        commands["btl"] = doBendTheLine;
        commands["srt"] = doStarThru;
        commands["sl"] = doStarThru;
        commands["pt"] = doPassThru;
        commands["tb"] = doTradeBy;
        commands["stw"] = doStepToAWave;
        commands["br"] = doBoysRun;
        commands["ptd"] = doTrade;
        commands["sb"] = doTrade;;
        commands["sq3"] = doTrade;;
        commands["utb"] = doTurnBack;
        commands["cdtl"] = doChainDownTheLine;
        commands["pto"] = doPassTheOcean;
        commands["fl"] = doFlutterWheel;
        commands["rfl"] = doReverseFlutterWheel;
        commands["tq"] = doTouchAQuarter;
        commands["circ"] = doCirculate;
        commands["hinge"] = doHinge;
        commands["fw"] = doFerrisWheel;
        commands["ptc"] = doPassToTheCenter;
        commands["rec"] = doRecycle;
        commands["ht"] = doHalfTag;

        // tell the user all the calls available. 
        let allCalls = []
        for(let key in commands)
            allCalls.push(key);
        allCalls.push("reset");        // add meta-calls
        allCalls.push("undo");
        allCalls.sort();
        allCallsSpan.innerHTML = allCalls.join(", ");

        /****************************************/
        // Global MUTABLE state (the model)
        // This is basically just the floor (a set of dancers)
        // all other globl state is in GUI object which 
        // we don't consider to be part of the model
        
        // create the initial floor (squared set)
        let floor = floorReset();
        
        // keeps track of calls we made, it is the model for the 'Call History' part of the GUI
        let callHistory = [];

        // draw the initial floor
        drawFloor(floor, mainCanvas);
        // draw the prev floor`
        drawFloor(undefined, prevCanvas);
        // The call History is already fine the way it is 

        // Some importnat invariants of floor
        //   * gridX and gridY are always small INTEGERS less than 6 in absolute value
        //   * The origin of this grid is the very center of the rectangle of dancers 
        //     in the GUI the origin is marked with a cross
        //   * X grows to the right, Y grows up (like in Math, NOT like in graphics)
        //   * a dancer's rotation is alwasy a number 0-3 (see NORTH, SOUTH, EAST, WEST)

        /*******************************************************************/
        // END OF STARTUP CODE.   
        // The rest of this code is function declrations that have no
        // obvious affect at the time the are scanned by javascript.
        /*******************************************************************/

        /********************************************************************/
        // operations on a single dancer (note deltas can be negative to move in the opposite direction)

        // moves a dancer in a given direction and changes its rotiation.
        // parameters can be negative 
        function dancerMove(dancer, forwardDelta, slideRightDelta, rotateCCWDelta) {
            console.assert(dancer.gridX == Math.floor(dancer.gridX));        // integer value
            console.assert(dancer.gridY == Math.floor(dancer.gridY));        // integer value
                
            if (dancer.rotation == NORTH) {
                dancer.gridY += forwardDelta;
                dancer.gridX += slideRightDelta;
            }
            else if (dancer.rotation == WEST) {
                dancer.gridY += slideRightDelta;
                dancer.gridX -= forwardDelta;
            }
            else if (dancer.rotation == SOUTH) {
                dancer.gridY -= forwardDelta;
                dancer.gridX -= slideRightDelta;
            }

            else if (dancer.rotation == EAST) {
                dancer.gridY -= slideRightDelta;
                dancer.gridX += forwardDelta;
            }

             // spin the given amount
             rotateCCWDelta += 4;
             dancer.rotation = (dancer.rotation + rotateCCWDelta) % 4;
        }

	// returns the amount to add (+1 or -1) to step forward
	function dancerForwardValue(dancer) {
            return (dancer.rotation == NORTH || dancer.rotation == EAST) ? 1 : -1;
	}

        // gets the coordinate of dancer (gridX or gridY) in its facing direction
        function dancerGetFacingCoordinate(dancer) {
            if (isFacingHeads(dancer))
                return dancer.gridX;
            else 
                return dancer.gridY;
        }

        // gets the coordinate of dancer (gridX or gridY) in its left-right direction
        function dancerGetCrossCoordinate(dancer) {
            if (isFacingHeads(dancer))
                return dancer.gridY;
            else 
                return dancer.gridX;
        }

        // a deep copy (which is also a shallow copy) of a dancer (used to make a deep copy of the floor)
        function copyDancer(dancer) {
            return Object.assign({}, dancer);
        }

        function stepForward(dancer, delta = 1) {
            if (dancer.rotation == SOUTH || dancer.rotation == WEST)
                delta = -delta;

            if (dancer.rotation == NORTH || dancer.rotation == SOUTH)
                dancer.gridY += delta;
            else 
                dancer.gridX += delta;
        }

        function slideRight(dancer, delta = 1) {
            rotateCCW(dancer, -1);
            stepForward(dancer, delta);
            rotateCCW(dancer, 1);
        }

        function rotateCCW(dancer, numCCWQuarter) {
             if (numCCWQuarter < 0)
                 numCCWQuarter += 4;
             dancer.rotation = (dancer.rotation + numCCWQuarter) % 4;
        }

        function isSides(dancer) {
            return dancer.number == 3 || dancer.number == 6;
        }
        function isHeads(dancer) {
            return !isSides(dancer);
        }

        function isFacingHeads(dancer) {
            return dancer.rotation % 2 == 0;
        }
        function isFacingSides(dancer) {
            return dancer.rotation % 2 == 1;
        }

        /*******************************************************************/
        // operations on two dancers 

        function swapPosAndDir(dancer1, dancer2) {
            swapPos(dancer1, dancer2);

            let temp = dancer1.rotation;
            dancer1.rotation = dancer2.rotation;
            dancer2.rotation = temp;
        }

        function swapPos(dancer1, dancer2) {
            let temp = dancer1.gridX;
            dancer1.gridX = dancer2.gridX;
            dancer2.gridX = temp;

            temp = dancer1.gridY;
            dancer1.gridY = dancer2.gridY;
            dancer2.gridY = temp;
        }

        /********************************************************************/
        /********************************************************************/
        // operations on the floor
        // the floor consists of a set of (in our case 12) dancers 

        function floorReset(floor) {
            if (floor == undefined)
                 floor = {};
            floor.dancers = [];
            makeCouple(floor.dancers, 1, -3, -3, NORTH);
            makeCouple(floor.dancers, 2, 1, -3,  NORTH);
            makeCouple(floor.dancers, 3, 5, -1, WEST);
            makeCouple(floor.dancers, 4, 3, 3, SOUTH);
            makeCouple(floor.dancers, 5, -1, 3, SOUTH);
            makeCouple(floor.dancers, 6, -5, 1, EAST);

            return floor;
        }

        // makes a deep copy of the floor.  
        function floorCopy(floor) {
            let ret = {}
            ret.dancers = [];
            for(let dancer of floor.dancers)
                ret.dancers.push(copyDancer(dancer));
            return ret;
        }

        function makeCouple(dancers, number, gridX, gridY, rotation) {

            // Create the boy dancer
            dancers.push({ isBoy:true, number:number, rotation:rotation, gridX:gridX, gridY:gridY });

            // create the girl dancer
            let girl = { isBoy:false, number:number, rotation:rotation, gridX:gridX, gridY:gridY };
            slideRight(girl, 2);

            dancers.push(girl);
        }

        /***********************************************************************/
        // Operations for figuring out what formation you have

        function horzLineLen(srtDancers, start = 0) {
            console.assert(srtDancers.length == 12);
            let gridY = srtDancers[start].gridY
            let ret = 1;
            for(let i = start+1; i < srtDancers.length; i++) {
                if (srtDancers[i].gridY != gridY)
                    break;
                ret++;
            }
            return ret;
        }

        // returns a list of dancers such that they are 'partnered up' 
        // this means that ever even entry A is standing next to A+1
        // If they are facing a positive direction (HORTH or EAST) then 
        // it is also the case that the even entries oare the BEAUs and the odd the BELLEs
        function floorSortForPartners(floor) {
            if (isFacingHeads(floor.dancers[0]))
                floor.dancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX)); // sort by Y A->Z then X A->Z
            else 
                floor.dancers.sort((a, b) => cmpOrder(a.gridX-b.gridX, b.gridY-a.gridY)); // sort by X A->Z then Y Z->A
            return floor.dancers;    // TODO remove ultimately
        }

	// returns true if the dancer is facing out of the entire formation
	function floorFacingOut(floor, dancer) {
	    // bounds of the formation in the facing direction
	    let minFacing = dancerGetFacingCoordinate(dancers[0]);
	    let maxFacing = dancerGetFacingCoordinate(dancers[dancers.length-1]);

	    // step forward tentatively
	    let stepForward = dancerGetFacingCoordinate(dancer) + dancerForwardValue(dancer);

	    // did we leave the formation?
	    return stepforward < minFacing || maxFacing < stepForward;
	}

        function cmpOrder(val1, val2) {
            if (val1 != 0)
                return val1;
            return val2;
        }

        function floorLineLen(floor, start = 0) {
            console.assert(floor.sorted);
        
            let gridY = dancerFacingDirection(floor.dancers[start]);
            let ret = 1;
            for(let i = start+1; i < srtDancers.length; i++) {
                if (dancerFacingDirection(floor.dancers[0]) != gridY)
                    break;
                ret++;
            }
            return ret;
        }

	// given a designatore (e.g. c = centers, e = ends, v = very centers, h = heads, s = sides) 
        // return an array of those dancers
	function floorGetDancers(designator) {
            console.assert(srtDancers.length == 12);
	}


        // get boxes from the floor.  A box is an array that orders 
        // its elements like this
        //    3 2
        //    0 1
        // where the dancers are facing north or south (never east or west)
        function getBoxes(floor) {
	    floorSortForPartners(floor); 
 
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));

            let ret;
            let needRotate;
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 6) {  
                // Assume 2 lines of 6 facing heads
                ret = [[srtDancers[0], srtDancers[1], srtDancers[7], srtDancers[6]],
                              [srtDancers[2], srtDancers[3], srtDancers[9], srtDancers[8]],
                           [srtDancers[4], srtDancers[5], srtDancers[11], srtDancers[10]] ];
                needRotate = isFacingSides(srtDancers[0]);  // In this case it is columns or triple box
            }
            else if (horzLen == 2 && horzLineLen(srtDancers, 2) == 2) {
                // Assume colums facing heads
                ret = [[srtDancers[0], srtDancers[1], srtDancers[3], srtDancers[2]],
                              [srtDancers[4], srtDancers[5], srtDancers[7], srtDancers[6]],
                           [srtDancers[8], srtDancers[9], srtDancers[11], srtDancers[10]]];
                needRotate = isFacingSides(srtDancers[0]); // 2 lines of 6
            }
            else 
                throw "Expected Boxes";

            if (needRotate) {
                for(let box of ret) 
                   rotateBoxCW(box)
            }
            return ret;
        }

        // returns dancers in 3 lines of 4.   First line is at the bottom
        function getLinesOf4(floor) {
	    floorSortForPartners(floor); 

	
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));

            let ret;
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 4) {  // 3 horizontal lines of 4
                ret = [[srtDancers[0], srtDancers[1], srtDancers[2], srtDancers[3]],
                       [srtDancers[4], srtDancers[5], srtDancers[6], srtDancers[7]],
                       [srtDancers[8], srtDancers[9], srtDancers[10], srtDancers[11]] ];
            }
            else if (horzLen == 3) {
                ret = [[srtDancers[9], srtDancers[6], srtDancers[3], srtDancers[0]],
                       [srtDancers[10], srtDancers[7], srtDancers[4], srtDancers[1]],
                       [srtDancers[11], srtDancers[8], srtDancers[5], srtDancers[2]]];
            }
            else 
                throw "Expected 3 lines of 4";

            return ret;
        }

        /*******************************************************************/
        /* other operations that are not square dance calls */

        function moveHeadsInIfNecessary(floor) {
        
            for(let dancer of floor.dancers) 
                if (isHeads(dancer) && Math.abs(dancer.gridY) == 3)
                    stepForward(dancer, 2);
        }

        function rotateBoxCW(box) {
            console.assert(box.length == 4);
            let temp = box[0];
            box[0] = box[3];
            box[3] = box[2];
            box[2] = box[1];
            box[1] = temp;
        }

        /*******************************************************************/
        /*                        SQUARE DANCE CALLS                       */

        /********************************************************************/
        // square dance calls that operate on boxes or lines  or couples ...

        function passTheOcean(box) {
            for(let beau of [box[0], box[2]])  {
                dancerMove(beau, 4, 1, -1);
            }
            
            for(let belle of [box[1], box[3]])  {
                stepForward(belle, 2);
                slideRight(belle, -1);
                rotateCCW(belle, 1);
            }
        }

        function trade(dancer1, dancer2) {
            swapPos(dancer1, dancer2)
            rotateCCW(dancer1, 2);
            rotateCCW(dancer2, 2);
        }
        
        function squareThru4(box) {
            rotateCCW(box[0], 1);
            rotateCCW(box[1], -1);
            rotateCCW(box[2], 1);
            rotateCCW(box[3], -1);
        }


        /********************************************************************/
        // square dance calls that operate on the whole floor 
        /********************************************************************/

        function doHome(floor) {
            floorReset(floor);
        }

        /*******************************/
        /* Basic 1 calls */

        function doHeadsLeadRight(floor) {

            moveHeadsInIfNecessary(floor);

            for(let dancer of floor.dancers) {
                if (isHeads(dancer)) {
                    if (dancer.isBoy) {
                        stepForward(dancer, 2);
                        slideRight(dancer, 2);
                    }                
                    rotateCCW(dancer, -1);
                }
            }
        }

        function doHeadsSquareThru4(floor) {

            moveHeadsInIfNecessary(floor);

            for(let dancer of floor.dancers) {
                if (isHeads(dancer))
                    rotateCCW(dancer, dancer.isBoy?1:-1);
            }
        }

        function doCentersPassThru(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 6 && srtDancers[0].rotation == 3)  {

                srtDancers = floorSortForPartners(floor)
                for(let i = 2; i < 10; i++)
                    stepForward(srtDancers[i], 2);
            }
            else
                throw "Formation Wrong for Centers pass thru";
        }

        function doCentersSquareThru3(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 6 && srtDancers[0].rotation == 3)  {

                srtDancers = floorSortForPartners(floor)
                for(let i = 2; i < 10; i += 2)
                    trade(srtDancers[i], srtDancers[i+1]);
            }
            else 
                throw "Formation Wrong for Centers Square Thru 3";
        }

        function doRightAndLeftThru(floor) {
            for(let box of getBoxes(floor)) {
                swapPosAndDir(box[0], box[2]);
                swapPosAndDir(box[1], box[3]);
            }
        }


        function doCentersCirculate(floor) {
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 3 && isFacingSides(srtDancers[0]))  {        // Three vertical lines
                let minX = srtDancers[0].gridX;
                let maxX = srtDancers[11].gridX;
                let delta = (maxX - minX) / 2;
                
                for(let i = 3; i < 9; i++) {
                    let dancer = srtDancers[i];
                    let inc = (dancer.rotation == 1) ? -delta : delta;

                    if (dancer.gridX == minX  && dancer.rotation == 1 ||   // min heading left
                        dancer.gridX == maxX  && dancer.rotation == 3) {   // max heading right
                        rotateCCW(dancer, 2);
                        dancer.gridY = -dancer.gridY;
                    }
                    else
                        dancer.gridX += inc;
                }
            }
        }

        function doEndsCirculate(floor) {
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 3 && isFacingSides(srtDancers[0]))  {        // Three vertical lines
                let minX = srtDancers[0].gridX;
                let maxX = srtDancers[11].gridX;
                let delta = (maxX - minX) / 2;
                
                for(let i = 0; i < srtDancers.length; i++) {
                    if (3 <= i && i < 9)
                        continue;
                    let dancer = srtDancers[i];
                    let inc = (dancer.rotation == 1) ? -delta : delta;

                    if (dancer.gridX == minX  && dancer.rotation == 1 ||   // min heading left
                        dancer.gridX == maxX  && dancer.rotation == 3) {   // max heading right
                        rotateCCW(dancer, 2);
                        dancer.gridY = -dancer.gridY;
                    }
                    else
                        dancer.gridX += inc;
                }
            }
        }

        function doCirculate(floor) {
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 3 && isFacingSides(srtDancers[0]))  {        // Three vertical lines
                let minX = srtDancers[0].gridX;
                let maxX = srtDancers[11].gridX;
                let delta = (maxX - minX) / 2;
                
                for(let dancer of srtDancers) {
                    let inc = (dancer.rotation == 1) ? -delta : delta;

                    if (dancer.gridX == minX  && dancer.rotation == 1 ||   // min heading left
                        dancer.gridX == maxX  && dancer.rotation == 3) {   // max heading right
                        rotateCCW(dancer, 2);
                        dancer.gridY = -dancer.gridY;
                    }
                    else
                        dancer.gridX += inc;
                }
            }
            else if (horzLen == 2 && isFacingHeads(srtDancers[0]))  {     // columns
                let minY = srtDancers[0].gridY;
                let maxY = srtDancers[11].gridY;
                let delta = (maxY - minY) / (12/horzLen - 1);
                
                for(let dancer of srtDancers) {
                    let inc = (dancer.rotation == 2) ? -delta : delta;

                    if (dancer.gridY == minY  && dancer.rotation == SOUTH ||   // min heading down
                        dancer.gridY == maxY  && dancer.rotation == NORTH) {   // max heading up
                        rotateCCW(dancer, 2);
                        dancer.gridX = -dancer.gridX;
                    }
                    else
                        dancer.gridY += inc;
                }
            }
            else if (horzLen == 6 && isFacingSides(srtDancers[0]))  {     // columns
                let minX = srtDancers[0].gridX;
                let maxX = srtDancers[11].gridX;
                let delta = (maxX - minX) / (horzLen - 1);
                
                for(let dancer of srtDancers) {
                    let inc = (dancer.rotation == 1) ? -delta : delta;

                    if (dancer.gridX == minX  && dancer.rotation == WEST ||
                        dancer.gridX == maxX  && dancer.rotation == EAST) {
                        rotateCCW(dancer, 2);
                        dancer.gridY = -dancer.gridY;
                    }
                    else
                        dancer.gridX += inc;
                }
            }

            else 
                throw "Expected lines";        // TODO handle other cases
        }

        function doVeerLeft(floor) {
            for(let dancer of floor.dancers) {
                stepForward(dancer);
                slideRight(dancer, -2);
            }
        }

        function doSquareThru4(floor) {
            for(let box of getBoxes(floor)) 
                squareThru4(box);
        }

        function doChainDownTheLine(floor) {
            for(let line of getLinesOf4(floor)) {
                for(let beau of [line[0], line[3]])  {
                    stepForward(beau);
                    slideRight(beau, 2);
                    rotateCCW(beau, -1);
                }
                
                for(let belle of [line[1], line[2]])  {
                    stepForward(belle);
                    slideRight(belle, 2);
                    rotateCCW(belle, 1);
                }
            }
        }

        function doTurnBack(floor) {
            for(let dancer of floor.dancers)
                rotateCCW(dancer, 2);
        }

        /*******************************/
        /* Basic 2 calls */

        function doHeadsPassTheOcean(floor) {
            moveHeadsInIfNecessary(floor);
            
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));

            passTheOcean([srtDancers[1], srtDancers[2], srtDancers[8], srtDancers[7]]);
            passTheOcean([srtDancers[3], srtDancers[4], srtDancers[10], srtDancers[9]]);
        }

        function doExtend(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));

            let horzLen = horzLineLen(srtDancers)
            let horzLen2 = horzLineLen(srtDancers, 2);
            if (horzLen == 2 && horzLen2 == 4) {
                srtDancers.sort((a, b) => cmpOrder(a.gridX-b.gridX, b.gridY-a.gridY));

                for(let i = 0; i < srtDancers.length; i++) { 
                    stepForward(srtDancers[i], (i <= 1 || 10 <= i) ? 1 : 2);
                    if (i == 0 || i == srtDancers.length-1)
                        slideRight(srtDancers[i], -2);
                }
            }
            else 
                throw "Expected QuarterTag";
        }

        function doFlutterWheel(floor) {
            for(let box of getBoxes(floor)) {
                swapPosAndDir(box[0], box[2]);
            }
        }

        function doReverseFlutterWheel(floor) {
            for(let box of getBoxes(floor)) {
                swapPosAndDir(box[1], box[3]);
            }
        }

        function doPassTheOcean(floor) {
            for(let box of getBoxes(floor)) 
                passTheOcean(box);
        }

        function doSwingThru(floor) {
            for(let line of getLinesOf4(floor)) {
                // ends and centers trade
                swapPosAndDir(line[0], line[1]);
                swapPosAndDir(line[2], line[3]);

                // centers trade (note that we have to use the ORIGINAL indexes
                // to fetch people now in the center
                swapPosAndDir(line[0], line[3]);
            }
        }

        function doCentersTrade(floor) {
            for(let line of getLinesOf4(floor)) {
                swapPosAndDir(line[1], line[2]);
            }
        }

        function doBoysRun(floor) {
            let srtDancers = floorSortForPartners(floor)
            for(let i = 0; i < 12; i+=2) {
                swapPos(srtDancers[i], srtDancers[i+1]);
                if (srtDancers[i].isBoy)
                    rotateCCW(srtDancers[i], 2);
                else
                    rotateCCW(srtDancers[i+1], 2);
            }
        }

        function doStepToAWave(floor) {
            let boxes = getBoxes(floor);

            for(let dancer of floor.dancers) {
                stepForward(dancer);
            }

            for(let box of boxes) {
                slideRight(box[0], -2);
                slideRight(box[2], -2);
            }
        }

        function doStarThru(floor) {
            for(let box of getBoxes(floor)) {
                swapPos(box[0], box[3]);
                swapPos(box[1], box[2])
                
                for(let dancer of box) 
                    rotateCCW(dancer, dancer.isBoy?-1:1);
            }
        }

        function doPassThru(floor) {
            for(let box of getBoxes(floor)) {
                swapPos(box[0], box[3]);
                swapPos(box[1], box[2]);
            }
        }

        function doTradeBy(floor) {
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 2)  {
                srtDancers.sort((a, b) => cmpOrder(b.gridX-a.gridX, a.gridY-b.gridY));
            }
            else if (horzLen != 6)
                throw "Expected Trade By formation"
            
            trade(srtDancers[0], srtDancers[6]);

            swapPos(srtDancers[1], srtDancers[2]);
            swapPos(srtDancers[7], srtDancers[8]);

            swapPos(srtDancers[3], srtDancers[4]);
            swapPos(srtDancers[9], srtDancers[10]);

            trade(srtDancers[5], srtDancers[11]);
        }

        function doBendTheLine(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 3)  {        // Three vertical lines
                for(let line of getLinesOf4(floor)) {
                    for(let end of [line[0], line[3]]) {
                        stepForward(end)
                        slideRight(end, 1);         // TODO handle left handed two faced lines
                        rotateCCW(end, -1);
                        stepForward(end);
                    }
                    for(let center of [line[1], line[2]]) {
                        stepForward(center, -1)
                        slideRight(center, -1);
                        rotateCCW(center, -1);
                        stepForward(center);
                    }
                }
                return;
            }
            else if (horzLen == 6 && srtDancers[0].rotation == 2) { // facing out toward heads
                _bendNormalizedLineOf6(srtDancers, 1);
            }
            else if (horzLen == 2 && srtDancers[0].rotation == 1) {            // facing out toward sides
                srtDancers.sort((a, b) => cmpOrder(a.gridX-b.gridX, b.gridY-a.gridY));
                _bendNormalizedLineOf6(srtDancers, -1);
            }
            else 
                throw "Expected lines";
        }

        function _bendNormalizedLineOf6(dancers, reflectBase) {
            let ctr = 0;
            for(let dancer of dancers) {
                let reflect = reflectBase * ((3 <= ctr && ctr < 9) ? -1 : 1);
                ctr++;

                let temp = dancer.gridX;
                dancer.gridX = dancer.gridY * reflect;
                dancer.gridY = temp * reflect;
                rotateCCW(dancer, reflectBase * reflect);
            }
        }

        function doTouchAQuarter(floor) {
            for(let box of getBoxes(floor)) {
                swapPos(box[0], box[3]);
                swapPos(box[1], box[2]);
                for(let dancer of box)
                    rotateCCW(dancer, -1);
            }
        }

        function doStretchFerrisWheel(floor) {
            let lines = getLinesOf4(floor);
	    for(let line of lines) {
	        require2Faced(line);
                for(let beau of [line[0], line[3]]) {
		     if (floorFacingOut(floor, beau)) {
			
		     }
		     else {
			
		     }
		}
                for(let belle of [line[1], line[2]]) {
		     if (floorFacingOut(floor, belle)) {
			
		     }
		     else {
		     }
		}
		
	    }
	}

        function doFerrisWheel(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 3 && srtDancers[0].rotation == 1)  {
                // boys facing out of square
                for(let beau of [srtDancers[0], srtDancers[11]]) {
                    stepForward(beau)
                    slideRight(beau, 4);
                    rotateCCW(beau, 2);
                }
                // girls facing out of square
                for(let belle of [srtDancers[3], srtDancers[8]]) {
                    stepForward(belle)
                    rotateCCW(belle, 2);
                }

                // boys facing in
                for(let beau of [srtDancers[9], srtDancers[10], srtDancers[2], srtDancers[1], ]) {
                    stepForward(beau, 3)
                    slideRight(beau, 4);
                    rotateCCW(beau, 2);
                }
                // girls facing in
                for(let belle of [srtDancers[6], srtDancers[7], srtDancers[5], srtDancers[4]]) {
                    stepForward(belle, 3)
                    rotateCCW(belle, 2);
                }
                return;
            }
            else 
                throw "Formation Wrong for Ferris Wheel";
        }

        /*******************************/
        /* MainStream calls */

        function doHinge(floor) {
            let srtDancers = floorSortForPartners(floor)
            for(let dancer of floor.dancers) {
                stepForward(dancer, 1);
                slideRight(dancer, 1);
                rotateCCW(dancer, -1);
            }
        }

        function doPassToTheCenter(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 6 && srtDancers[0].rotation == 3)  {

                srtDancers = floorSortForPartners(floor)
                for(let dancer of srtDancers)
                    stepForward(dancer, 2);

                // remember you have to use the STARTING index 
                trade(srtDancers[2], srtDancers[3]);
                trade(srtDancers[8], srtDancers[9]);
            }
            else
                throw "Formation Wrong for Pass To The Center";
        }

        function doTrade(floor) {
            let srtDancers = floorSortForPartners(floor)
            for(let i = 0; i < 12; i+=2)
                trade(srtDancers[i], srtDancers[i+1]);
        }

        function doRecycle(floor) {
            for(let line of getLinesOf4(floor)) {
                for(let beau of [line[0], line[3]]) {
                    stepForward(beau)
                    slideRight(beau, 4);
                    rotateCCW(beau, 2);
                }
                for(let belle of [line[1], line[2]]) {
                    stepForward(belle, -1)
                }
            }
        }

        function doHalfTag(floor) {
            for(let line of getLinesOf4(floor)) {
                for(let beau of [line[0], line[3]]) {
                    stepForward(beau);
                    rotateCCW(beau, -1);
                    stepForward(beau)
                }
                for(let belle of [line[1], line[2]]) {
                    stepForward(belle, 1);
                    rotateCCW(belle, -1);
                    stepForward(belle, 3)
                }
            }
        }

        /********************************************************************/
        // END OF SQUARE DANCE CALLS
        /********************************************************************/

        /********************************************************************/
        // GUI Drawing support

        // puts the orgin in the center and makes y grow up not down
        // Thus it acts like how you would set up x,y in math class. 
        function setOriginInCenter(canvas, canvasContext) {
        
            let centerX = canvas.width / 2;
            let centerY = canvas.height / 2;

            canvasContext.translate (centerX, centerY);
            canvasContext.scale(1, -1);
        }

        function drawFloor(floor, canvas) {
            const canvasContext = canvas.getContext('2d');
        
            canvasContext.clearRect(0, 0, canvas.width, canvas.height);

            // number of pixels between dancer position grid
            // for width == 500 -> gridSize == 40
            const gridSize = canvas.width / 12.5;

            // Draw a grid of dots
            setOriginInCenter(canvas, canvasContext);
            canvasContext.fillStyle = "black";
            for(let x = -6; x <= 6; x++) {
                for(let y = -6; y <= 6; y++) {
                    canvasContext.beginPath();
                    canvasContext.arc(x * gridSize, y * gridSize, 2, 0, 2 * Math.PI); 
                    canvasContext.fill();        
                }
            }
                // draw a cross on the origin
            canvasContext.beginPath();
            canvasContext.moveTo(gridSize, 0);
            canvasContext.lineTo(-gridSize, 0);
            canvasContext.moveTo(0, gridSize);
            canvasContext.lineTo(0, -gridSize);
            canvasContext.stroke();
            
            if (floor === undefined)
                return;

            canvasContext.setTransform(1, 0, 0, 1, 0, 0);

               // draw Dancers
            for(let dancer of floor.dancers) {
                 drawDancer(dancer, canvas, canvasContext, gridSize)
            }

            canvasContext.setTransform(1, 0, 0, 1, 0, 0);
        }

        function drawDancer(dancer, canvas, canvasContext, gridSize) {
            setOriginInCenter(canvas, canvasContext);

            canvasContext.translate (dancer.gridX * gridSize , dancer.gridY * gridSize);

            canvasContext.rotate(Math.PI / 2.0 * dancer.rotation)
            canvasContext.fillStyle = colors[dancer.number-1];

                // draw boy or girl
            if (dancer.isBoy) 
                canvasContext.fillRect(-0.35*gridSize, -0.35*gridSize, 0.7*gridSize, 0.7*gridSize);
            else  {
                canvasContext.beginPath();
                canvasContext.arc(0, 0, 0.4*gridSize, 0, 2 * Math.PI); 
                canvasContext.fill();        
            }
                // draw bulge
            canvasContext.beginPath();
            canvasContext.arc(0, 0.38*gridSize, 0.2*gridSize, 0, 2 * Math.PI); 
            canvasContext.fill();        
        
                // draw the couple number
            canvasContext.rotate(-Math.PI / 2.0 * dancer.rotation)
            canvasContext.scale(1, -1);
            canvasContext.font =  (gridSize / 2) + "px Arial";
            canvasContext.fillStyle = "black";
            canvasContext.fillText(dancer.number, -gridSize*0.15, gridSize*0.2);

            canvasContext.setTransform(1, 0, 0, 1, 0, 0);
        }

        /********************************************************************/
        // logic for handling GUI callbacks 

        // called when textbox changes (someone hits enter or paste in it)
        function doCommandOnChange() {
            let call = commandTextbox.value;        
            commandTextbox.value = "";
            doCall(call)
        }

        function doCall(call) {
            console.log("doCall", call);
            if (call == "t") {
                 doTest();
                 return;
            }
            if (call == "reset") {
                callListSpan.innerHTML = "";
                floorReset(floor);
                callHistory = [];
                drawFloor(floor, mainCanvas);
                drawFloor(undefined, prevCanvas);
                messageSpan.innerHTML = "Reset!";
                return true
            }
            else if (call == "undo") {
                if (0 < callHistory.length) {
                    let prev = callHistory.pop();
                    floor = floorCopy(prev.start);
                    messageSpan.innerHTML = "Undid: <b>" + prev.call + "</b>";
                        
                    callListSpan.innerHTML = "";
                    for(let callHistoryElem of callHistory) 
                        callListSpan.innerHTML += callHistoryElem.call + "<br>";
                    
                    drawFloor(floor, mainCanvas);
                        
                    if (0 < callHistory.length) {
                        drawFloor(callHistory[callHistory.length-1].start, prevCanvas);
                        messageSpan.innerHTML += " last call now: <b>" + callHistory[callHistory.length-1].call + "</b>";
                    }
                    else 
                        drawFloor(undefined, prevCanvas);
                }
                else {
                    logError("Nothing to undo");
                    return false;
                }
                return true;
            }

            let cmdFtn = commands[call];
            if (cmdFtn == undefined) {
                // map spaces to ~ in things like "h sq4" so they look like a single call.
                let calls = call.replace(/\b([hsbgce]) /g, "$1~").split(/\s+/);
                if (1 < calls.length) {
                    for(let subCall of calls) {
                        if (!doCall(subCall.replace(/~/g, " ")))  // remove the ~ we used to rep a space
                            return false;
                    }
                }
                else {
                    logError("Unrecognised Call: " + call);
                    return false;
                }
                return true;
            }

            let startFloor;
            if (0 < callHistory.length)
                startFloor = callHistory[callHistory.length-1].end;
            else 
                startFloor = floorCopy(floor);

            try {
                cmdFtn(floor);
            } catch(err) {
                 logError("Error Executing Call: " + err);
                 return false;
            }
            drawFloor(floor, mainCanvas);
            messageSpan.innerHTML = "Finished Call: " + call;
            
            callHistory.push({ start:startFloor, call:call, end:floorCopy(floor) });
            drawFloor(startFloor, prevCanvas);

            callListSpan.innerHTML += call + "<br>";
            return true;
        }

        function logError(message) {
            beep();
            messageSpan.innerHTML = "<b>" + message + "</b>";
        }

        /********************************************************************/
        // support for sound (beeps)

        function beep() { tone(50, 440); }

        function tone(duration, frequency) {
            if (audioCtx === undefined)
                audioCtx = new window.AudioContext;
            let oscillator = audioCtx.createOscillator();
            let gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = frequency;
            // oscillator.type = "sine"; 

            oscillator.start();
            setTimeout(function () { oscillator.stop() }, duration);
        };
        let audioCtx;

        /********************************************************************/
        /********************************************************************/
        // TESTING    Called by the 't' command to allow quick unit testing

        function doTest() {
            doCall("reset h pto ex st br cdtl pt btl tq circ circ circ br sq4 btl srt pt");
            messageSpan.innerHTML = "<b>" + "Finished Testing" + "</b>";
        }
    </script>
</body>

</html>
