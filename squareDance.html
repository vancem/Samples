<!doctype html>
<html>

<body>
    <!-- *********************************************************************** -->
    <!-- The body section describes the visual layout of the page -->

    <p> This is a program that simulates square dance calls for a 6 couple rectangle.
        This was inspired by the 
        <a href="https://www.tamtwirlers.org/taminations/#?main=SEQUENCER&formation=Squared%20Set" target="_blank">
        Taminations sequencer</a>.  You can get the definitions for Mainstream square dance calls at 
        <a href="https://www.tamtwirlers.org/taminations/#?level=Basic%20and%20Mainstream&main=LEVELS&detail=CALLS" target="_blank">
        Taminations mainstream list</a>.
    </p> <p>
        The error handling is rudimentary at best. It has also only been
        tested in 'simple' cases, but it does seem to work if you stick to 
        valid call sequences.   
    <ul>
        <li> Calls are given very short abbreviations that are mostly the first letter of 
             each word in the call (exeptions below).  Couple circulate is just circulate.
        <li> h=heads, c=centers, e=ends, v = very centers, fl=flutterwheel srt=star thru, sfw = stretch ferris wheel
             st=swing thru, td=trade, sl=slide thru</li>
        <li> Calls Available: <span id=allCalls></span> </li>

        <li> Must explicitly call step to a wave (stw) from facing couples.
        <li> You can paste multiple commands (sep by space) into textbox.
        
    </ul> <ul>
        <li> Type Calls here: <input id=command type=text onchange="doCommandOnChange()"> 
             <button onClick="doCommand('reset')">reset</button>
             <button onClick="doCommand('undo')">undo</button>
        </li>
        <li> Message: <span id=message></span> </li>
    </ul>
    <div style="display:flex"> 
        <canvas id=main tabindex=1 style="border:2px solid red" height=500 width=500> </canvas>
        <div style="background-color:lightgray;height:500px;overflow-y:scroll"> 
            <p style="margin:10px">
                <b>Call History</b><br> 
                <span id=callList></span>
            </p>
        </div> 
        <div style="background-color:#dfedf5"> 
            <div style="text-align:center;margin:10px;font-size:x-large;font-weight:bold">Previous Dancer Positions</div>
            <canvas id=prev style="border:2px solid red;background-color:lightgray;vertical-align:bottom" height=400 width=400> </canvas>
        </div>
    </div> 

    <!-- *************************** END OF HTML ******************************* -->

    <script>
        "use strict";                // do extra error checking at load time

        /***********************************************************************/
        // STARTUP code.   This initializes global constants, GUI constants, 
        // and the model for the program (the dance floor)

        // Global CONSTANTS 
        // get GUI objects needed
        const g_mainCanvas = document.getElementById('main');
        const g_prevCanvas = document.getElementById('prev');

        const g_commandTextbox = document.getElementById('command');
        const g_messageSpan = document.getElementById('message');
        const g_callListSpan = document.getElementById('callList');
        const g_allCallsSpan = document.getElementById('allCalls');

        // Values for dancers based on their dancer number 
        const colors = ["red", "green", "cyan", "yellow", "violet", "blue" ];

        // Values for dancer.rotation.  These work like map directions
        const NORTH = 0;
        const WEST = 1;
        const SOUTH = 2;
        const EAST = 3;

        // commands maps call names to the method that performs it used in doCommand
        const CALL_TO_FTN = getCallFtns();

        /****************************************/
        // Global MUTABLE state (the model)
        // This is basically just the floor (a set of dancers)
        // all other globl state is in GUI object which 
        // we don't consider to be part of the model
        
        // create the initial floor (squared set)
        let g_floor = floorReset();
        // the state before the current floor, can be undefined.
        let g_prevFloor = undefined;
        
        // keeps track of calls we made, it is the model for the 'Call History' part of the GUI
        let g_callHistory = [];

        // Run any startup needed to get the GUI in the desired start up state.
        startup();

        /*******************************************************************/
        // END OF STARTUP CODE.   
        // The rest of this code is function declrations that have no
        // obvious affect at the time the are scanned by javascript.
        /*******************************************************************/

        /********************************************************************/
        // code that is run at startup 
        function startup() {

                // tell the user all the calls available. 
            let allCalls = []
            for(let key in CALL_TO_FTN)
                allCalls.push(key);
            allCalls.push("reset");        // add meta-calls
            allCalls.push("undo");
            allCalls.sort();
            g_allCallsSpan.innerHTML = allCalls.join(", ");

            syncGUIToModel();
        }

        /********************************************************************/
        // operations on a single dancer (note deltas can be negative to move in the opposite direction)

        // moves a dancer in a given direction and changes its rotiation.
        // parameters can be negative 
        function dancerMove(dancer, forwardDelta, slideRightDelta, rotateCCWDelta) {
            console.assert(dancer.gridX == Math.floor(dancer.gridX));        // integer value
            console.assert(dancer.gridY == Math.floor(dancer.gridY));        // integer value
                
            if (dancer.rotation == NORTH) {
                dancer.gridY += forwardDelta;
                dancer.gridX += slideRightDelta;
            }
            else if (dancer.rotation == WEST) {
                dancer.gridY += slideRightDelta;
                dancer.gridX -= forwardDelta;
            }
            else if (dancer.rotation == SOUTH) {
                dancer.gridY -= forwardDelta;
                dancer.gridX -= slideRightDelta;
            }

            else if (dancer.rotation == EAST) {
                dancer.gridY -= slideRightDelta;
                dancer.gridX += forwardDelta;
            }

             // spin the given amount
             rotateCCWDelta += 4;
             dancer.rotation = (dancer.rotation + rotateCCWDelta) % 4;
        }

        // returns the amount to add (+1 or -1) to step forward
        function dancerForwardValue(dancer) {
            return (dancer.rotation == NORTH || dancer.rotation == EAST) ? 1 : -1;
        }

        // gets the coordinate of dancer (gridX or gridY) in its facing direction
        // thus if you are facing heads, you get gridY (since you move in this direction fowward and back)
        function dancerGetFacingCoordinate(dancer) {
            if (isFacingHeads(dancer))
                return dancer.gridY;
            else 
                return dancer.gridX;
        }

        function dancerScaleFacingCoordinate(dancer, factor) {
            if (isFacingHeads(dancer))
                dancer.gridY *= factor;
            else 
                dancer.gridX *= factor;
        }


        // gets the coordinate of dancer (gridX or gridY) in its left-right direction
        function dancerGetCrossCoordinate(dancer) {
            if (isFacingHeads(dancer))
                return dancer.gridX;
            else 
                return dancer.gridY;
        }

        // a deep copy (which is also a shallow copy) of a dancer (used to make a deep copy of the floor)
        function dancerCopy(dancer) {
            let ret = Object.assign({}, dancer);
            return ret;
        }

        function stepForward(dancer, delta = 1) {
            if (dancer.rotation == SOUTH || dancer.rotation == WEST)
                delta = -delta;

            if (dancer.rotation == NORTH || dancer.rotation == SOUTH)
                dancer.gridY += delta;
            else 
                dancer.gridX += delta;
        }

        function slideRight(dancer, delta = 1) {
            rotateCCW(dancer, -1);
            stepForward(dancer, delta);
            rotateCCW(dancer, 1);
        }

        function rotateCCW(dancer, numCCWQuarter) {
             if (numCCWQuarter < 0)
                 numCCWQuarter += 4;
             dancer.rotation = (dancer.rotation + numCCWQuarter) % 4;
        }

        function isSides(dancer) {
            return dancer.number == 3 || dancer.number == 6;
        }
        function isHeads(dancer) {
            return !isSides(dancer);
        }

        function isFacingHeads(dancer) {
            return dancer.rotation % 2 == 0;
        }
        function isFacingSides(dancer) {
            return dancer.rotation % 2 == 1;
        }

        /*******************************************************************/
        // operations on two dancers 

        function swapPosAndDir(dancer1, dancer2) {
            swapPos(dancer1, dancer2);

            let temp = dancer1.rotation;
            dancer1.rotation = dancer2.rotation;
            dancer2.rotation = temp;
        }

        function swapPos(dancer1, dancer2) {
            let temp = dancer1.gridX;
            dancer1.gridX = dancer2.gridX;
            dancer2.gridX = temp;

            temp = dancer1.gridY;
            dancer1.gridY = dancer2.gridY;
            dancer2.gridY = temp;
        }

        /********************************************************************/
        /********************************************************************/
        // operations on the floor
        // the floor consists of a set of (in our case 12) dancers 

        // Some important invariants of floor
        //   * gridX and gridY are always small INTEGERS less than 6 in absolute value
        //   * The origin of this grid is the very center of the rectangle of dancers 
        //     in the GUI the origin is marked with a cross
        //   * X grows to the right, Y grows up (like in Math, NOT like in graphics)
        //   * a dancer's rotation is alwasy a number 0-3 (see NORTH, SOUTH, EAST, WEST)

        function floorReset(floor) {
            if (floor == undefined)
                 floor = {};
            floor.dancers = [];
            makeCouple(floor.dancers, 1, -3, -3, NORTH);
            makeCouple(floor.dancers, 2, 1, -3,  NORTH);
            makeCouple(floor.dancers, 3, 5, -1, WEST);
            makeCouple(floor.dancers, 4, 3, 3, SOUTH);
            makeCouple(floor.dancers, 5, -1, 3, SOUTH);
            makeCouple(floor.dancers, 6, -5, 1, EAST);

            return floor;
        }

        // makes a deep copy of the floor.  
        function floorCopy(floor) {
            let ret = {}
            ret.dancers = [];
            for(let dancer of floor.dancers)
                ret.dancers.push(dancerCopy(dancer));
            return ret;
        }

        // floorAssign sets 'to' to be a deep copy of 'from'
        function floorAssign(to, from) {
            let copy = floorCopy(from);        // Make a deep copy
            Object.assign(to, copy);        // shallow copy into to 
        }

        function makeCouple(dancers, number, gridX, gridY, rotation) {

            // Create the boy dancer
            dancers.push({ isBoy:true, number:number, rotation:rotation, gridX:gridX, gridY:gridY });

            // create the girl dancer
            let girl = { isBoy:false, number:number, rotation:rotation, gridX:gridX, gridY:gridY };
            slideRight(girl, 2);

            dancers.push(girl);
        }

        /***********************************************************************/
        // Operations for figuring out what formation you have

        function horzLineLen(srtDancers, start = 0) {
            console.assert(srtDancers.length == 12);
            let gridY = srtDancers[start].gridY
            let ret = 1;
            for(let i = start+1; i < srtDancers.length; i++) {
                if (srtDancers[i].gridY != gridY)
                    break;
                ret++;
            }
            return ret;
        }

        // returns a list of dancers such that they are 'partnered up' 
        // this means that ever even entry A is standing next to A+1
        // If they are facing a positive direction (HORTH or EAST) then 
        // it is also the case that the even entries oare the BEAUs and the odd the BELLEs
        function floorSortForPartners(floor) {
            if (isFacingHeads(floor.dancers[0]))
                floor.dancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX)); // sort by Y A->Z then X A->Z
            else 
                floor.dancers.sort((a, b) => cmpOrder(a.gridX-b.gridX, b.gridY-a.gridY)); // sort by X A->Z then Y Z->A

            floor.minFacing = dancerGetFacingCoordinate(floor.dancers[0]);
            floor.maxFacing = dancerGetFacingCoordinate(floor.dancers[floor.dancers.length-1]);

            return floor.dancers;    // TODO remove ultimately
        }

        // returns true if the dancer is facing out of the entire formation
        function floorFacingOut(floor, dancer) {

            // step forward tentatively
            let stepForward = dancerGetFacingCoordinate(dancer) + dancerForwardValue(dancer);

            // did we leave the formation?
            return stepForward < floor.minFacing || floor.maxFacing < stepForward;
        }

        function cmpOrder(val1, val2) {
            if (val1 != 0)
                return val1;
            return val2;
        }

        function dancersLineLen(dancers, start = 0) {

            let gridY = dancerGetFacingCoordinate(dancers[start]);
            let i;
            for(i = start+1; i < dancers.length; i++) {
                if (dancerGetFacingCoordinate(dancers[i]) != gridY)
                    break;
            }
            return i;
        }

        // given a designatore (e.g. c = centers, e = ends, v = very centers, h = heads, s = sides) 
        // return an array of those dancers
        function floorGetDancers(floor, designator) {
            floorSortForPartners(floor); 

            if (!designator)
                return floor.dancers;

            // This is one of the places we care that we have 12 dancers
            console.assert(floor.dancers.length == 12);

            // TODO fail if the formations are wrong for the designator (currently we blindly apply) 

            let lineLen = dancersLineLen(floor.dancers);
            if (designator == "v") {
                if (lineLen == 2)
                    return floor.dancers.slice(4, 8);
                else
                    throw "Can't Determine Very Centers.";
            }
            if (designator == "c") {
                if (lineLen == 2)
                    return floor.dancers.slice(2, 10);
                else if (lineLen == 4)
                    return [ dancers[1], dancers[2], dancers[5], dancers[6], dancers[9], dancers[10] ];
                else
                    throw "Can't Determine Centers.";
            }
            if (designator == "e") {
                if (lineLen == 2)
                    return [ dancers[0], dancers[1], dancers[10], dancers[11] ];
                else if (lineLen == 4)
                    return [ dancers[0], dancers[3], dancers[4], dancers[7], dancers[8], dancers[11] ];
                else
                    throw "Can't Determine Ends.";
            }
            throw "Unsupported Designator " + designator;
        }

        function dancersGetBoxes(dancers) {
            let lineLen = dancersLineLen(dancers);
            if (lineLen != 2 && lineLen != 6)
                throw "Bad formation (can't find boxes).";
            
            let ret = []
            for(let boxI = 0; boxI < dancers.length;  boxI += 2 * lineLen) {
                for(let i = 0; i < lineLen; i += 2)
                    ret.push([dancers[i+boxI], dancers[i+1+boxI], dancers[lineLen+i+boxI], dancers[lineLen+i+1+boxI]]);
            }
            return ret;
        }

        function dancersGetLinesOf4(dancers) {
            let lineLen = dancersLineLen(dancers);
            if (lineLen != 4)
                throw "Bad formation (can't find lines of 4).";
            
            return [ dancers.slice(0,4), dancers.slice(4,8), dancers.slice(8,12) ];
        }


        // get boxes from the floor.  A box is an array that orders 
        // its elements like this
        //    3 2
        //    0 1
        // where the dancers are facing north or south (never east or west)
        function getBoxes(floor) {
 
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));

            let ret;
            let needRotate;
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 6) {  
                // Assume 2 lines of 6 facing heads
                ret = [[srtDancers[0], srtDancers[1], srtDancers[7], srtDancers[6]],
                              [srtDancers[2], srtDancers[3], srtDancers[9], srtDancers[8]],
                           [srtDancers[4], srtDancers[5], srtDancers[11], srtDancers[10]] ];
                needRotate = isFacingSides(srtDancers[0]);  // In this case it is columns or triple box
            }
            else if (horzLen == 2 && horzLineLen(srtDancers, 2) == 2) {
                // Assume colums facing heads
                ret = [[srtDancers[0], srtDancers[1], srtDancers[3], srtDancers[2]],
                              [srtDancers[4], srtDancers[5], srtDancers[7], srtDancers[6]],
                           [srtDancers[8], srtDancers[9], srtDancers[11], srtDancers[10]]];
                needRotate = isFacingSides(srtDancers[0]); // 2 lines of 6
            }
            else 
                throw "Expected Boxes";

            if (needRotate) {
                for(let box of ret) 
                   rotateBoxCW(box)
            }
            return ret;
        }

        // returns dancers in 3 lines of 4.   First line is at the bottom
        function getLinesOf4(floor) {
        
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));

            let ret;
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 4) {  // 3 horizontal lines of 4
                ret = [[srtDancers[0], srtDancers[1], srtDancers[2], srtDancers[3]],
                       [srtDancers[4], srtDancers[5], srtDancers[6], srtDancers[7]],
                       [srtDancers[8], srtDancers[9], srtDancers[10], srtDancers[11]] ];
            }
            else if (horzLen == 3) {
                ret = [[srtDancers[9], srtDancers[6], srtDancers[3], srtDancers[0]],
                       [srtDancers[10], srtDancers[7], srtDancers[4], srtDancers[1]],
                       [srtDancers[11], srtDancers[8], srtDancers[5], srtDancers[2]]];
            }
            else 
                throw "Expected 3 lines of 4";

            return ret;
        }

        /*******************************************************************/
        /* other operations that are not square dance calls */

        function moveHeadsInIfNecessary(floor) {
        
            for(let dancer of floor.dancers) 
                if (isHeads(dancer) && Math.abs(dancer.gridY) == 3)
                    stepForward(dancer, 2);
        }

        function rotateBoxCW(box) {
            console.assert(box.length == 4);
            let temp = box[0];
            box[0] = box[3];
            box[3] = box[2];
            box[2] = box[1];
            box[1] = temp;
        }

        /*******************************************************************/
        /*                        SQUARE DANCE CALLS                       */

        /********************************************************************/
        // square dance calls that operate on boxes or lines  or couples ...

        function passTheOcean(box) {
            for(let beau of [box[0], box[2]])  {
                dancerMove(beau, 4, 1, -1);
            }
            
            for(let belle of [box[1], box[3]])  {
                stepForward(belle, 2);
                slideRight(belle, -1);
                rotateCCW(belle, 1);
            }
        }

        function trade(dancer1, dancer2) {
            swapPos(dancer1, dancer2)
            rotateCCW(dancer1, 2);
            rotateCCW(dancer2, 2);
        }
        

        /********************************************************************/
        // square dance calls that operate on the whole floor 
        /********************************************************************/

        function doHome(floor) {
            floorReset(floor);
        }

        /*******************************/
        /* Basic 1 calls */

        function doHeadsLeadRight(floor) {

            moveHeadsInIfNecessary(floor);

            for(let dancer of floor.dancers) {
                if (isHeads(dancer)) {
                    if (dancer.isBoy) {
                        stepForward(dancer, 2);
                        slideRight(dancer, 2);
                    }                
                    rotateCCW(dancer, -1);
                }
            }
        }

        function doHeadsSquareThru4(floor) {

            moveHeadsInIfNecessary(floor);

            for(let dancer of floor.dancers) {
                if (isHeads(dancer))
                    rotateCCW(dancer, dancer.isBoy?1:-1);
            }
        }

        function doCentersSquareThru3(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 6 && srtDancers[0].rotation == 3)  {

                srtDancers = floorSortForPartners(floor)
                for(let i = 2; i < 10; i += 2)
                    trade(srtDancers[i], srtDancers[i+1]);
            }
            else 
                throw "Formation Wrong for Centers Square Thru 3";
        }

        function doRightAndLeftThru(floor, dancers) {
            for(let box of dancersGetBoxes(dancers)) {
                swapPosAndDir(box[0], box[3]);
                swapPosAndDir(box[1], box[2]);
            }
            floor.sweepCCW = 1;
        }


        function doCentersCirculate(floor) {
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 3 && isFacingSides(srtDancers[0]))  {        // Three vertical lines
                let minX = srtDancers[0].gridX;
                let maxX = srtDancers[11].gridX;
                let delta = (maxX - minX) / 2;
                
                for(let i = 3; i < 9; i++) {
                    let dancer = srtDancers[i];
                    let inc = (dancer.rotation == 1) ? -delta : delta;

                    if (dancer.gridX == minX  && dancer.rotation == 1 ||   // min heading left
                        dancer.gridX == maxX  && dancer.rotation == 3) {   // max heading right
                        rotateCCW(dancer, 2);
                        dancer.gridY = -dancer.gridY;
                    }
                    else
                        dancer.gridX += inc;
                }
            }
        }

        function doEndsCirculate(floor) {
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 3 && isFacingSides(srtDancers[0]))  {        // Three vertical lines
                let minX = srtDancers[0].gridX;
                let maxX = srtDancers[11].gridX;
                let delta = (maxX - minX) / 2;
                
                for(let i = 0; i < srtDancers.length; i++) {
                    if (3 <= i && i < 9)
                        continue;
                    let dancer = srtDancers[i];
                    let inc = (dancer.rotation == 1) ? -delta : delta;

                    if (dancer.gridX == minX  && dancer.rotation == 1 ||   // min heading left
                        dancer.gridX == maxX  && dancer.rotation == 3) {   // max heading right
                        rotateCCW(dancer, 2);
                        dancer.gridY = -dancer.gridY;
                    }
                    else
                        dancer.gridX += inc;
                }
            }
        }

        function doCirculate(floor) {
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 3 && isFacingSides(srtDancers[0]))  {        // Three vertical lines
                let minX = srtDancers[0].gridX;
                let maxX = srtDancers[11].gridX;
                let delta = (maxX - minX) / 2;
                
                for(let dancer of srtDancers) {
                    let inc = (dancer.rotation == 1) ? -delta : delta;

                    if (dancer.gridX == minX  && dancer.rotation == 1 ||   // min heading left
                        dancer.gridX == maxX  && dancer.rotation == 3) {   // max heading right
                        rotateCCW(dancer, 2);
                        dancer.gridY = -dancer.gridY;
                    }
                    else
                        dancer.gridX += inc;
                }
            }
            else if (horzLen == 2 && isFacingHeads(srtDancers[0]))  {     // columns
                let minY = srtDancers[0].gridY;
                let maxY = srtDancers[11].gridY;
                let delta = (maxY - minY) / (12/horzLen - 1);
                
                for(let dancer of srtDancers) {
                    let inc = (dancer.rotation == 2) ? -delta : delta;

                    if (dancer.gridY == minY  && dancer.rotation == SOUTH ||   // min heading down
                        dancer.gridY == maxY  && dancer.rotation == NORTH) {   // max heading up
                        rotateCCW(dancer, 2);
                        dancer.gridX = -dancer.gridX;
                    }
                    else
                        dancer.gridY += inc;
                }
            }
            else if (horzLen == 6 && isFacingSides(srtDancers[0]))  {     // columns
                let minX = srtDancers[0].gridX;
                let maxX = srtDancers[11].gridX;
                let delta = (maxX - minX) / (horzLen - 1);
                
                for(let dancer of srtDancers) {
                    let inc = (dancer.rotation == 1) ? -delta : delta;

                    if (dancer.gridX == minX  && dancer.rotation == WEST ||
                        dancer.gridX == maxX  && dancer.rotation == EAST) {
                        rotateCCW(dancer, 2);
                        dancer.gridY = -dancer.gridY;
                    }
                    else
                        dancer.gridX += inc;
                }
            }

            else 
                throw "Expected lines";        // TODO handle other cases
        }

        function doVeerLeft(floor) {
            for(let dancer of floor.dancers) {
                stepForward(dancer);
                slideRight(dancer, -2);
            }
        }

        function doSquareThru4(floor, dancers) {
            for(let box of dancersGetBoxes(dancers)) {
                dancerMove(box[0], 0, 0, 1);
                dancerMove(box[1], 0, 0, -1);
                dancerMove(box[2], 0, 0, -1);
                dancerMove(box[3], 0, 0, 1);
            }
        }

        function doChainDownTheLine(floor) {
            for(let line of getLinesOf4(floor)) {
                for(let beau of [line[0], line[3]])  {
                    stepForward(beau);
                    slideRight(beau, 2);
                    rotateCCW(beau, -1);
                }
                
                for(let belle of [line[1], line[2]])  {
                    stepForward(belle);
                    slideRight(belle, 2);
                    rotateCCW(belle, 1);
                }
            }
           floor.sweepCCW = 1;
        }

        function doTurnBack(floor) {
            for(let dancer of floor.dancers)
                rotateCCW(dancer, 2);
        }

        /*******************************/
        /* Basic 2 calls */

        function doHeadsPassTheOcean(floor) {
            moveHeadsInIfNecessary(floor);
            
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));

            passTheOcean([srtDancers[1], srtDancers[2], srtDancers[8], srtDancers[7]]);
            passTheOcean([srtDancers[3], srtDancers[4], srtDancers[10], srtDancers[9]]);
        }

        function doExtend(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));

            let horzLen = horzLineLen(srtDancers)
            let horzLen2 = horzLineLen(srtDancers, 2);
            if (horzLen == 2 && horzLen2 == 4) {
                srtDancers.sort((a, b) => cmpOrder(a.gridX-b.gridX, b.gridY-a.gridY));

                for(let i = 0; i < srtDancers.length; i++) { 
                    stepForward(srtDancers[i], (i <= 1 || 10 <= i) ? 1 : 2);
                    if (i == 0 || i == srtDancers.length-1)
                        slideRight(srtDancers[i], -2);
                }
            }
            else 
                throw "Expected QuarterTag";
        }

        function doSweepAQuarter(floor, dancers) {
            for(let box of dancersGetBoxes(dancers)) {
                if (floor.sweepCCW == 1) {
                    dancerMove(box[0], 0, 2, 1);
                    dancerMove(box[1], 2, 0, 1);
                    dancerMove(box[2], 2, 0, 1);
                    dancerMove(box[3], 0, 2, 1);
                }
                else if (floor.sweepCCW == -1) {
                    dancerMove(box[0], 2, 0, -1);
                    dancerMove(box[1], 0, -2, -1);
                    dancerMove(box[2], 0, -2, -1);
                    dancerMove(box[3], 2, 0, -1);
                }
                else 
                    throw "Sweep 1/4 requires previous call to have 2 dancer flow.";
            }
        }

        function doFlutterWheel(floor, dancers) {
            for(let box of dancersGetBoxes(dancers)) {
                dancerMove(box[0], 2, 2, 2);
                dancerMove(box[3], 2, 2, 2);
            }
           floor.sweepCCW = -1;
        }

        function doReverseFlutterWheel(floor, dancers) {
            for(let box of dancersGetBoxes(dancers)) {
                dancerMove(box[1], 2, -2, 2);
                dancerMove(box[2], 2, -2, 2);
            }
           floor.sweepCCW = 1;
        }

        function doPassTheOcean(floor) {
            for(let box of getBoxes(floor)) 
                passTheOcean(box);
        }

        function doSwingThru(floor) {
            for(let line of getLinesOf4(floor)) {
                // ends and centers trade
                swapPosAndDir(line[0], line[1]);
                swapPosAndDir(line[2], line[3]);

                // centers trade (note that we have to use the ORIGINAL indexes
                // to fetch people now in the center
                swapPosAndDir(line[0], line[3]);
            }
        }

        function doCentersTrade(floor) {
            for(let line of getLinesOf4(floor)) {
                swapPosAndDir(line[1], line[2]);
            }
        }

        function doBoysRun(floor) {
            let srtDancers = floorSortForPartners(floor)
            for(let i = 0; i < 12; i+=2) {
                swapPos(srtDancers[i], srtDancers[i+1]);
                if (srtDancers[i].isBoy)
                    rotateCCW(srtDancers[i], 2);
                else
                    rotateCCW(srtDancers[i+1], 2);
            }
        }

        function doStepToAWave(floor) {
            let boxes = getBoxes(floor);

            for(let dancer of floor.dancers) {
                stepForward(dancer);
            }

            for(let box of boxes) {
                slideRight(box[0], -2);
                slideRight(box[2], -2);
            }
        }

        function doStarThru(floor, dancers) {
            for (let dancer of dancers) 
                dancerMove(dancer, 2, 0, dancer.isBoy ? -1 : 1);
        }

        function doPassThru(floor, dancers) {
            for(let dancer of dancers) {
                dancerMove(dancer, 2, 0, 0);
            }
        }

        function doTradeBy(floor) {
            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 2)  {
                srtDancers.sort((a, b) => cmpOrder(b.gridX-a.gridX, a.gridY-b.gridY));
            }
            else if (horzLen != 6)
                throw "Expected Trade By formation"
            
            trade(srtDancers[0], srtDancers[6]);

            swapPos(srtDancers[1], srtDancers[2]);
            swapPos(srtDancers[7], srtDancers[8]);

            swapPos(srtDancers[3], srtDancers[4]);
            swapPos(srtDancers[9], srtDancers[10]);

            trade(srtDancers[5], srtDancers[11]);
        }

        function doBendTheLine(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 3)  {        // Three vertical lines
                for(let line of getLinesOf4(floor)) {
                    for(let end of [line[0], line[3]]) {
                        stepForward(end)
                        slideRight(end, 1);         // TODO handle left handed two faced lines
                        rotateCCW(end, -1);
                        stepForward(end);
                    }
                    for(let center of [line[1], line[2]]) {
                        stepForward(center, -1)
                        slideRight(center, -1);
                        rotateCCW(center, -1);
                        stepForward(center);
                    }
                }
                floor.sweepCCW = -1; // only for 2 faced, but that is the only kind possible here  TODO handle left handed
                return;
            }
            else if (horzLen == 6 && srtDancers[0].rotation == 2) { // facing out toward heads
                _bendNormalizedLineOf6(srtDancers, 1);
            }
            else if (horzLen == 2 && srtDancers[0].rotation == 1) {            // facing out toward sides
                srtDancers.sort((a, b) => cmpOrder(a.gridX-b.gridX, b.gridY-a.gridY));
                _bendNormalizedLineOf6(srtDancers, -1);
            }
            else 
                throw "Expected lines";
        }

        function _bendNormalizedLineOf6(dancers, reflectBase) {
            let ctr = 0;
            for(let dancer of dancers) {
                let reflect = reflectBase * ((3 <= ctr && ctr < 9) ? -1 : 1);
                ctr++;

                let temp = dancer.gridX;
                dancer.gridX = dancer.gridY * reflect;
                dancer.gridY = temp * reflect;
                rotateCCW(dancer, reflectBase * reflect);
            }
        }

        function doTouchAQuarter(floor, dancers) {
            for(let box of dancersGetBoxes(dancers)) {
                swapPos(box[0], box[2]);
                swapPos(box[1], box[3]);
                for(let dancer of box)
                    rotateCCW(dancer, -1);
            }
        }

        // Handles Wheel+Deal (stretch=1), Ferris Wheel(stretch=3) and Stretch Ferris Wheel (stretch=5)
        function doWheelFamily(floor, dancers, stretch) {
            let lines = dancersGetLinesOf4(dancers) 
            for(let i = 0; i < lines.length; i++)  {
                let line = lines[i];
                let dancerStretch = stretch;
                if (stretch == 5 && i == 1)        // For stretch ferris wheel, the middle group is not stretched.
                    dancerStretch = 3;

                for(let beau of [line[0], line[3]]) {
                    if (floorFacingOut(floor, beau)) 
                        dancerMove(beau, 1, 4, 2);
                    else 
                        dancerMove(beau, dancerStretch, 4, 2);
                }
                for(let belle of [line[1], line[2]]) {
                    if (floorFacingOut(floor, belle))
                        dancerMove(belle, 1, 0, 2);
                    else 
                        dancerMove(belle, dancerStretch, 0, 2);
                }
            }
           floor.sweepCCW = -1;        // only for centers
        }

        function doStretchFerrisWheel(floor, dancers) {
            doWheelFamily(floor, dancers, 5);
        }
        function doFerrisWheel(floor, dancers) {
            doWheelFamily(floor, dancers, 3);
        }
        function doWheelAndDeal(floor, dancers) {
            doWheelFamily(floor, dancers, 1);
        }

        /*******************************/
        /* MainStream calls */

        function doHinge(floor, dancers) { 

            let lineLen = dancersLineLen(dancers);
            if (lineLen == 6) {
                for(let dancer of dancers) 
                    dancerScaleFacingCoordinate(dancer, 2);
            }

            for(let dancer of floor.dancers) {
                stepForward(dancer, 1);
                slideRight(dancer, 1);
                rotateCCW(dancer, -1);
            }

            // if we started with 3 lines of 4 we end up with two lines of 6
            if (lineLen == 4) {
                 for(let dancer of dancers) 
                     dancerScaleFacingCoordinate(dancer, 0.5);
            }
        }

        function doPassToTheCenter(floor) {

            // sort bottom first to top then left to right
            let srtDancers = floor.dancers.slice();
            srtDancers.sort((a, b) => cmpOrder(a.gridY-b.gridY, a.gridX-b.gridX));
        
            let horzLen = horzLineLen(srtDancers)
            if (horzLen == 6 && srtDancers[0].rotation == 3)  {

                srtDancers = floorSortForPartners(floor)
                for(let dancer of srtDancers)
                    stepForward(dancer, 2);

                // remember you have to use the STARTING index 
                trade(srtDancers[2], srtDancers[3]);
                trade(srtDancers[8], srtDancers[9]);
            }
            else
                throw "Formation Wrong for Pass To The Center";
        }

        function doTrade(floor, dancers) {
            for(let i = 0; i < dancers.length; i+=2)  {
                trade(dancers[i], dancers[i+1]);
            }
        }

        function doRecycle(floor) {
            for(let line of getLinesOf4(floor)) {
                for(let beau of [line[0], line[3]]) {
                    stepForward(beau)
                    slideRight(beau, 4);
                    rotateCCW(beau, 2);
                }
                for(let belle of [line[1], line[2]]) {
                    stepForward(belle, -1)
                }
            }
            floor.sweepCCW = -1;
        }

        function doHalfTag(floor, dancers) {
            let lines = dancersGetLinesOf4(dancers);
            console.log("got lines", lines);
            for(let line of lines) {
                console.log("got line", line);
                for(let beau of [line[0], line[3]])  {
                     console.log("got dancer", beau);
                    dancerMove(beau, 1, 2, -1)
                }
                for(let belle of [line[1], line[2]]) {
                    dancerMove(belle, 1, 2, -1)
                }
            }
        }

        /********************************************************************/
        // END OF SQUARE DANCE CALLS
        /********************************************************************/

        /********************************************************************/
        // GUI Drawing support

        // puts the orgin in the center and makes y grow up not down
        // Thus it acts like how you would set up x,y in math class. 
        function setOriginInCenter(canvas, canvasContext) {
        
            let centerX = canvas.width / 2;
            let centerY = canvas.height / 2;

            canvasContext.translate (centerX, centerY);
            canvasContext.scale(1, -1);
        }

        function drawFloor(floor, canvas) {
            console.log("Drawing floor")
            const canvasContext = canvas.getContext('2d');
        
            canvasContext.clearRect(0, 0, canvas.width, canvas.height);

            // number of pixels between dancer position grid
            // for width == 500 -> gridSize == 40
            const gridSize = canvas.width / 12.5;

            // Draw a grid of dots
            setOriginInCenter(canvas, canvasContext);
            canvasContext.fillStyle = "black";
            for(let x = -6; x <= 6; x++) {
                for(let y = -6; y <= 6; y++) {
                    canvasContext.beginPath();
                    canvasContext.arc(x * gridSize, y * gridSize, 2, 0, 2 * Math.PI); 
                    canvasContext.fill();        
                }
            }
                // draw a cross on the origin
            canvasContext.beginPath();
            canvasContext.moveTo(gridSize, 0);
            canvasContext.lineTo(-gridSize, 0);
            canvasContext.moveTo(0, gridSize);
            canvasContext.lineTo(0, -gridSize);
            canvasContext.stroke();
            
            if (floor === undefined)
                return;

            canvasContext.setTransform(1, 0, 0, 1, 0, 0);

               // draw Dancers
            for(let dancer of floor.dancers) {
                 drawDancer(dancer, canvas, canvasContext, gridSize)
            }

            canvasContext.setTransform(1, 0, 0, 1, 0, 0);
        }

        function drawDancer(dancer, canvas, canvasContext, gridSize) {
            setOriginInCenter(canvas, canvasContext);

            canvasContext.translate (dancer.gridX * gridSize , dancer.gridY * gridSize);

            canvasContext.rotate(Math.PI / 2.0 * dancer.rotation)
            canvasContext.fillStyle = colors[dancer.number-1];

                // draw boy or girl
            if (dancer.isBoy) 
                canvasContext.fillRect(-0.35*gridSize, -0.35*gridSize, 0.7*gridSize, 0.7*gridSize);
            else  {
                canvasContext.beginPath();
                canvasContext.arc(0, 0, 0.4*gridSize, 0, 2 * Math.PI); 
                canvasContext.fill();        
            }
                // draw bulge
            canvasContext.beginPath();
            canvasContext.arc(0, 0.38*gridSize, 0.2*gridSize, 0, 2 * Math.PI); 
            canvasContext.fill();        
        
                // draw the couple number
            canvasContext.rotate(-Math.PI / 2.0 * dancer.rotation)
            canvasContext.scale(1, -1);
            canvasContext.font =  (gridSize / 2) + "px Arial";
            canvasContext.fillStyle = "black";
            canvasContext.fillText(dancer.number, -gridSize*0.15, gridSize*0.2);

            canvasContext.setTransform(1, 0, 0, 1, 0, 0);
        }

        /********************************************************************/
        // logic for handling GUI callbacks 

        // called when textbox changes (someone hits enter or paste in it)
        function doCommandOnChange() {
            let call = g_commandTextbox.value;        
            g_commandTextbox.value = "";
            doCommand(call, g_floor)

        }

        function doCommand(command) {
            console.log("doCommand", command);

            while(true) {
                let match = command.match(/^(([hsbgcev]) )?(\S+)\s*(.*)$/);
                if (!match) 
                    break;
             
                let designator = match[2];
                let call = match[3];
                command = match[4];

                if (checkForCommand(g_floor, call))
                    continue;

                if (!doCall(g_floor, call, designator))
                    break;
            }
            syncGUIToModel();
        }

        function checkForCommand(floor, command) {
             // Hidden for testing 
            if (command == "t") {
                 doTest();
                 return true;
            }

            if (command == "reset") {
                g_callListSpan.innerHTML = "";
                floorReset(floor);
                g_callHistory = [];
                g_messageSpan.innerHTML = "Reset complete.";
                return true
            }

            if (command == "undo") {
                if (0 < g_callHistory.length) {
                    let prev = g_callHistory.pop();
                    floorAssign(g_floor, prev.start);
                    g_messageSpan.innerHTML = "Undid: <b>" + prev.call + "</b>";
                        
                    g_prevFloor = undefined;
                    if (0 < g_callHistory.length) {
                        let prevHistory = g_callHistory[g_callHistory.length-1];
                        g_prevFloor = prevHistory.start;
                        g_messageSpan.innerHTML += " last call now: <b>" + prevHistory.call + "</b>";
                    }
                }
                else 
                    logError("Nothing to undo.");
                return true;
            }
        
            return false;
        }

        function doCall(floor, call, designator) {
            // Remember the starting point for the floor
            let startFloor;
            if (0 < g_callHistory.length)
                startFloor = g_callHistory[g_callHistory.length-1].end;
            else 
                startFloor = floorCopy(floor);
        
            // remember our sweep direction for sweepa quarter
            if (call != "saq")
                floor.sweepCCW = 0;                // 0 means no sweep  

            let fullCall = call;
            if (designator)
                fullCall = designator + " " + fullCall;

            try {
                    // TODO REMOVE after we dont have desginators in the calls
                if (designator && CALL_TO_FTN[fullCall]) {
                    call = fullCall
                    designator = undefined;
                }
                let dancers = floorGetDancers(floor, designator);
                    
                let callFtn = CALL_TO_FTN[call];
                if (!callFtn) {
                     logError("Error, Unknownn call : " + call);
                     return false;
                }

                callFtn(floor, dancers);

            } catch(err) {
                 logError("Error Executing Call: " + err);
                 floorAssign(floor, startFloor);        // restore the state. 
                 return false;
            }

            g_messageSpan.innerHTML = "Finished Call: " + fullCall;

            g_prevFloor = startFloor;                // This is the model the GUI uses

                // remember the history
            g_callHistory.push({ start:startFloor, call:fullCall, end:floorCopy(floor) });

                // update the GUI for the history.
            g_callListSpan.innerHTML += fullCall + "<br>";
            return true;
        }

        function logError(message) {
            beep();
            g_messageSpan.innerHTML = "<b>" + message + "</b>";
        }

        function getCallFtns() {
            let ret = {};
            ret["h pto"] = doHeadsPassTheOcean;
            ret["h lr"] = doHeadsLeadRight;
            ret["h pto"] = doHeadsPassTheOcean;
            ret["h sq4"] = doHeadsSquareThru4;
            ret["c circ"] = doCentersCirculate;
            ret["e circ"] = doEndsCirculate;
            ret["c sq3"] = doCentersSquareThru3;
            ret["c td"] = doCentersTrade;
            ret["st"] = doSwingThru;
            ret["sq4"] = doSquareThru4;
            ret["ex"] = doExtend;
            ret["home"] = doHome;
            ret["rlt"] = doRightAndLeftThru;
            ret["vl"] = doVeerLeft;
            ret["btl"] = doBendTheLine;
            ret["srt"] = doStarThru;
            ret["sl"] = doStarThru;
            ret["pt"] = doPassThru;
            ret["tb"] = doTradeBy;
            ret["stw"] = doStepToAWave;
            ret["br"] = doBoysRun;
            ret["ptd"] = doTrade;
            ret["sb"] = doTrade;;
            ret["sq3"] = doTrade;;
            ret["utb"] = doTurnBack;
            ret["cdtl"] = doChainDownTheLine;
            ret["pto"] = doPassTheOcean;
            ret["saq"] = doSweepAQuarter;
            ret["fl"] = doFlutterWheel;
            ret["fl"] = doFlutterWheel;
            ret["rfl"] = doReverseFlutterWheel;
            ret["tq"] = doTouchAQuarter;
            ret["circ"] = doCirculate;
            ret["hinge"] = doHinge;
            ret["whd"] = doWheelAndDeal;
            ret["fw"] = doFerrisWheel;
            ret["sfw"] = doStretchFerrisWheel;
            ret["ptc"] = doPassToTheCenter;
            ret["rec"] = doRecycle;
            ret["ht"] = doHalfTag;
            return ret;
        }

        function syncGUIToModel() {
            console.log("in syncGUIToModel", g_floor);
            drawFloor(g_floor, g_mainCanvas);
            drawFloor(g_prevFloor, g_prevCanvas);

                // Update the history list
            let historyStr = ""
            for(let g_callHistoryElem of g_callHistory) 
                historyStr += g_callHistoryElem.call + "<br>";
            g_callListSpan.innerHTML = historyStr;
        }

        /********************************************************************/
        // support for sound (beeps)

        function beep() { tone(50, 440); }

        function tone(duration, frequency) {
            if (audioCtx === undefined)
                audioCtx = new window.AudioContext;
            let oscillator = audioCtx.createOscillator();
            let gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = frequency;
            // oscillator.type = "sine"; 

            oscillator.start();
            setTimeout(function () { oscillator.stop() }, duration);
        };
        let audioCtx;

        /********************************************************************/
        /********************************************************************/
        // TESTING    Called by the 't' command to allow quick unit testing

        function doTest() {
            doCommand("reset h pto ex st br cdtl pt btl tq circ circ circ br sq4 btl srt pt");
            g_messageSpan.innerHTML = "<b>" + "Finished Testing" + "</b>";
        }
    </script>
</body>

</html>
