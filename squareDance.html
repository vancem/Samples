<!doctype html>
<html>

<body onkeydown="onKeyDown(event)">
    <!-- *********************************************************************** -->
    <!-- The body section describes the visual layout of the page -->

    <p> This is a program that simulates square dance calls for a 6 couple rectangle.
        This was inspired by the
        <a href="https://www.tamtwirlers.org/taminations/#?main=SEQUENCER&formation=Squared%20Set" target="_blank">
            Taminations sequencer</a>. You can get the definitions for Mainstream square dance calls at
        <a href="https://www.tamtwirlers.org/taminations/#?level=Basic%20and%20Mainstream&main=LEVELS&detail=CALLS"
            target="_blank">
            Taminations mainstream list</a>.
    </p>
    <ul>
        <li> Calls are given very short abbreviations that are mostly the first letter of
            each word in the call (exeptions below). Couple circulate is just circulate.
        <li> h=heads, c=centers, e=ends, v = very centers, fl=flutterwheel srt=star thru, sfw = stretch ferris wheel
            st=swing thru, td=trade, sl=slide thru</li>
        <li> Calls Available: <span id=allCalls></span> </li>
        <li> Typically Must explicitly call step to a wave (stw) from facing couples.
        <li> You can paste multiple commands (separated by space) into textbox.
        <li> You can click on the history list (or use arrow keys) to move around in the history.</li>
        <li> To try it out, type the following (one at a time, without commas): h pto,ex,st,br,fw,c sq3

    </ul>
    <ul>
        <li> <button onClick="onCommand('reset')">reset</button>
            <button onClick="onCommand('undo')">undo</button>
            Type Calls here: <input id=command type=text onchange="textBoxOnChange(event)">
            <span id=resolved
                style="visibility:hidden;display:inline-block;color:red;background-color:rgb(183,181,247);vertical-align:middle;margin:0px 20px;text-align:center;">Resolved!</span>
        </li>
        <li> Message: <span id=message></span> </li>
    </ul>
    <div style="display:flex">
        <canvas id=main tabindex=1 style="border:2px solid red" height=500 width=500> </canvas>
        <div style="background-color:lightgray;height:500px;min-width:120px;overflow-y:scroll">
            <p>
                <b style="display:inline-block;margin:0px 5px">Call History</b><br>
            <ol id=callList></ol>
            </p>
        </div>
        <div style="background-color:#dfedf5">
            <div style="text-align:center;margin:10px;font-size:x-large;font-weight:bold">Previous Dancer Positions
            </div>
            <canvas id=prev style="border:2px solid red;background-color:lightgray;vertical-align:bottom" height=400
                width=400> </canvas>
        </div>
    </div>
    <!-- *************************** END OF HTML ******************************* -->

    <script>
        "use strict";                // do extra error checking at load time

        /***********************************************************************/
        // STARTUP code.   This initializes global constants, GUI constants, 
        // and the model for the program (the dance floor)

        // Global CONSTANTS 
        // get GUI objects needed
        const g_mainCanvas = document.getElementById('main');
        const g_prevCanvas = document.getElementById('prev');
        const g_messageSpan = document.getElementById('message');
        const g_allCallsSpan = document.getElementById('allCalls');
        const g_resolvedsSpan = document.getElementById('resolved');

        const g_callListOrderedList = document.getElementById('callList');

        // Values for dancers based on their dancer number 
        const COLORS = ["red", "green", "cyan", "yellow", "violet", "blue"];

        // Values for dancer.rotation.  These work like map directions
        const NORTH = 0;
        const WEST = 1;
        const SOUTH = 2;
        const EAST = 3;

        // commands maps call names to the method that performs it used in doCommand
        const CALL_TO_FTN = getCallFtns();

        /****************************************/
        // Global MUTABLE state (the model)

        // The model is embodied in a single structure the history list.
        // Each element in this list is a call, along with its floor before 
        // the call, and the floor after the call.   
        let g_callHistory = [];

        // This is the start of the 'viewModel' state.  This is information that the GUI
        // keeps track of but arguably is not part of the model because it makes sense
        // for the GUI, but not for an API for the model 
        let g_callListSelectedItemIdx = -1;      // initialized to be g_callHistory.length-1

        // Run any startup needed to get the GUI in the desired start up state.
        startup();

        /*******************************************************************/
        // END OF STARTUP CODE.   
        // The rest of this code is function declrations that have no
        //  effect at the time the are scanned by javascript.
        /*******************************************************************/

        /********************************************************************/
        // code that is run at startup 
        function startup() {

            // tell the user all the calls available. (g_allCallsSpan)
            let allCalls = []
            for (let key in CALL_TO_FTN)
                allCalls.push(key);
            allCalls.push("reset");        // add meta-calls
            allCalls.push("undo");
            allCalls.sort();
            g_allCallsSpan.innerHTML = allCalls.join(", ");

            syncGUIToModel();
        }

        /********************************************************************/
        // operations on a single dancer (note deltas can be negative to move in the opposite direction)

        // moves a dancer in a given direction and changes its rotiation.
        // parameters can be negative 
        function dancerMove(dancer, forwardDelta, slideRightDelta, rotateCCWDelta) {
            console.assert(dancer.gridX == Math.floor(dancer.gridX));        // integer value
            console.assert(dancer.gridY == Math.floor(dancer.gridY));        // integer value

            if (dancer.rotation == NORTH) {
                dancer.gridY += forwardDelta;
                dancer.gridX += slideRightDelta;
            }
            else if (dancer.rotation == WEST) {
                dancer.gridY += slideRightDelta;
                dancer.gridX -= forwardDelta;
            }
            else if (dancer.rotation == SOUTH) {
                dancer.gridY -= forwardDelta;
                dancer.gridX -= slideRightDelta;
            }

            else if (dancer.rotation == EAST) {
                dancer.gridY -= slideRightDelta;
                dancer.gridX += forwardDelta;
            }

            // spin the given amount
            rotateCCWDelta += 4;
            dancer.rotation = (dancer.rotation + rotateCCWDelta) % 4;
        }

        // returns the amount to add (+1 or -1) to step forward
        function dancerForwardValue(dancer) {
            return (dancer.rotation == NORTH || dancer.rotation == EAST) ? 1 : -1;
        }

        // gets the coordinate of dancer (gridX or gridY) in its facing direction
        // thus if you are facing heads, you get gridY (since you move in this direction fowward and back)
        function dancerGetFacingCoordinate(dancer) {
            if (dancerIsFacingHeads(dancer))
                return dancer.gridY;
            else
                return dancer.gridX;
        }

        // gets the direction that you change to move left or right.   
        function dancerGetCrossCoordinate(dancer) {
            if (dancerIsFacingHeads(dancer))
                return dancer.gridX;
            else
                return dancer.gridY;
        }

        function dancerScaleFacingCoordinate(dancer, factor) {
            if (dancerIsFacingHeads(dancer))
                dancer.gridY = Math.round(dancer.gridY * factor);
            else
                dancer.gridX = Math.round(dancer.gridX * factor);
        }

        // a deep copy (which is also a shallow copy) of a dancer (used to make a deep copy of the floor)
        function dancerCopy(dancer) {
            let ret = Object.assign({}, dancer);
            return ret;
        }

        function dancerIsSides(dancer) {
            return dancer.number == 3 || dancer.number == 6;
        }
        function dancerIsHeads(dancer) {
            return !dancerIsSides(dancer);
        }

        function dancerIsFacingHeads(dancer) {
            return dancer.rotation % 2 == 0;
        }

        function dancerIsFacingSides(dancer) {
            return dancer.rotation % 2 == 1;
        }

        /********************************/
        // operations on two dancers 

        function swapPos(dancer1, dancer2) {
            let temp = dancer1.gridX;
            dancer1.gridX = dancer2.gridX;
            dancer2.gridX = temp;

            temp = dancer1.gridY;
            dancer1.gridY = dancer2.gridY;
            dancer2.gridY = temp;
        }

        function trade(dancer1, dancer2) {
            swapPos(dancer1, dancer2)
            dancerMove(dancer1, 0, 0, 2);
            dancerMove(dancer2, 0, 0, 2);
        }

        // In a sorted list of dancers, determine how long the 
        // line is (if you look to your right, how many people
        // do you see with the same facing coordinate).   
        function dancersLineLen(dancers, start = 0) {
            let gridY = dancerGetFacingCoordinate(dancers[start]);
            let i;
            for (i = start + 1; i < dancers.length; i++) {
                if (dancerGetFacingCoordinate(dancers[i]) != gridY)
                    break;
            }
            return i - start;
        }

        // given a list of dancers THAT ARE SORTED, return a array of boxes.   
        // a box is a array of 4 dancers.  Logically the dancers in the box
        // are arranged like
        //     2 3
        //     0 1 
        function dancersGetBoxes(dancers) {
            let lineLen = dancersLineLen(dancers);
            if (lineLen % 2 != 0 || dancers.length % (lineLen * 2) != 0)
                throw "Bad formation (can't find boxes).";

            let ret = []
            for (let boxI = 0; boxI < dancers.length; boxI += 2 * lineLen) {
                for (let i = 0; i < lineLen; i += 2)
                    ret.push([dancers[i + boxI], dancers[i + 1 + boxI],
                    dancers[lineLen + i + boxI], dancers[lineLen + i + 1 + boxI]]);
            }
            return ret;
        }

        // given a list of dancers THAT ARE SORTED, return a array of lines of 4 dancers
        // the dancers are arranged from left to right if you face NORTH-SOUTH
        // and arranged top to bottom if you face EAST-WEST
        function dancersGetLinesOf4(dancers) {
            let lineLen = dancersLineLen(dancers);
            if (lineLen != 4)
                throw "Bad formation (can't find lines of 4).";

            return [dancers.slice(0, 4), dancers.slice(4, 8), dancers.slice(8, 12)];
        }

        // returns true if the two dancers are facing
        function dancersIsFacingOpposite(dancer1, dancer2) {
            return Math.abs(dancer1.rotation - dancer2.rotation) == 2;
        }

        function dancerFacingAwayFromCenter(dancer) {
            let forward = dancerForwardValue(dancer);                               // 1 if going away from orgin
            let normalizedPos = dancerGetFacingCoordinate(dancer) >= 0 ? 1 : -1;      // 1 if orgin at my back.  
            return forward == normalizedPos;
        }

        /********************************************************************/
        /********************************************************************/
        // operations on the floor  
        // the floor consists of a set of (in our case 12) dancers 

        // Some important invariants of floor
        //   * gridX and gridY are always small INTEGERS less than 6 in absolute value
        //   * The origin of this grid is the very center of the rectangle of dancers 
        //     in the GUI the origin is marked with a cross
        //   * X grows to the right, Y grows up (like in Math, NOT like in graphics)
        //   * a dancer's rotation is alwasy a number 0-3 (see NORTH, SOUTH, EAST, WEST)

        function floorReset(floor) {
            if (floor == undefined)
                floor = {};
            floor.dancers = [];
            floor.isResolved = false;

            floorMakeCouple(floor.dancers, 1, -3, -3, NORTH);
            floorMakeCouple(floor.dancers, 2, 1, -3, NORTH);
            floorMakeCouple(floor.dancers, 3, 5, -1, WEST);
            floorMakeCouple(floor.dancers, 4, 3, 3, SOUTH);
            floorMakeCouple(floor.dancers, 5, -1, 3, SOUTH);
            floorMakeCouple(floor.dancers, 6, -5, 1, EAST);

            return floor;
        }

        // makes a deep copy of the floor.  
        function floorDeepCopy(floor) {
            // do a shallow copy 
            let ret = Object.assign({}, floor);

            // Need a deeper copy of the dancers
            ret.dancers = [];
            for (let dancer of floor.dancers)
                ret.dancers.push(dancerCopy(dancer));
            return ret;
        }

        function floorMakeCouple(dancers, number, gridX, gridY, rotation) {

            // Create the boy dancer
            dancers.push({ isBoy: true, number: number, rotation: rotation, gridX: gridX, gridY: gridY });
            // create the girl dancer
            let girl = { isBoy: false, number: number, rotation: rotation, gridX: gridX, gridY: gridY };
            dancerMove(girl, 0, 2, 0);

            dancers.push(girl);
        }

        /***********************************************************************/
        // Operations for figuring out what formation you have

        // returns true if the dancer is facing out of the entire formation
        function floorIsFacingOut(floor, dancer) {

            // step forward tentatively
            let stepForward = dancerGetFacingCoordinate(dancer) + dancerForwardValue(dancer);

            // did we leave the formation?
            return stepForward < floor.minFacing || floor.maxFacing < stepForward;
        }

        function cmpOrder(val1, val2) {
            if (val1 != 0)
                return val1;
            return val2;
        }

        function floorIsResolved(floor) {
            let dancers = floor.dancers;

            // We iterate through the dancers 'around the outside counter clockwise' (promenade order)
            // this gets us the sequence 0 2 4 6 8 10 11 9 7 5 3 1 
            function dancerLoc(dancer) { return (dancer < 6) ? (2 * dancer + 1) : (10 - 2 * (dancer - 6)); }

            //  first transform 1-6 to 0-5 then add one then mod, then traslate back.  
            function dancerNextNum(num) { return num % 6 + 1; }

            for (let i = 0; i < 12; i++) {
                let curDancer = dancers[dancerLoc(i)];
                let nextDancer = dancers[dancerLoc((i + 1) % 12)];
                if (nextDancer.isBoy == curDancer.isBoy)    // we alternate genders
                    return false;

                if (curDancer.isBoy) {                      // the next needs to be your parner
                    if (nextDancer.number != curDancer.number)
                        return false;
                }
                else {                                      // next dancer is the girls corner
                    if (nextDancer.number != dancerNextNum(curDancer.number))
                        return false

                    // either you are facing your corner or you are both facing out
                    if (floorIsFacingOut(floor, curDancer)) {
                        if (!floorIsFacingOut(floor, nextDancer))
                            return false;
                    }
                    else {
                        if (!dancersIsFacingOpposite(nextDancer, curDancer))
                            return false;
                    }
                }
            }
            return true;
        }

        // given a designator (e.g. c = centers, e = ends, v = very centers, h = heads, s = sides) 
        // return an array of those dancers.  The returned dancers are sorted 
        // * left to right if the dancers are facing NORTH or SOUTH
        // * top to bottom if the dancers are facing EAST or WEST  
        // In particular this makes the dancers paired up.  
        function floorGetDancers(floor, designator) {

            let dancers = floor.dancers;
            let isDesignatedHeadsOrSides = false;

            if (designator == "h") {
                dancers = [];
                for (let dancer of floor.dancers) {
                    if (dancerIsHeads(dancer))
                        dancers.push(dancer)
                }
                isDesignatedHeadsOrSides = true;
            }
            else if (designator == "s") {
                dancers = [];
                for (let dancer of floor.dancers) {
                    if (dancerIsSides(dancer))
                        dancers.push(dancer)
                }
                isDesignatedHeadsOrSides = true;
            }

            // Sort the dancers so that all couples are next to each other.  couples go from FLOOR left to right
            // (thus sashayed couples might be surprising)
            if (dancerIsFacingHeads(dancers[0]))
                dancers.sort((a, b) => cmpOrder(a.gridY - b.gridY, a.gridX - b.gridX)); // sort by Y A->Z then X A->Z
            else
                dancers.sort((a, b) => cmpOrder(a.gridX - b.gridX, b.gridY - a.gridY)); // sort by X A->Z then Y Z->A

            floor.minFacing = dancerGetFacingCoordinate(dancers[0]);
            floor.maxFacing = dancerGetFacingCoordinate(dancers[dancers.length - 1]);

            if (isDesignatedHeadsOrSides || !designator)
                return dancers;

            // This is one of the places we care that we have 12 dancers
            console.assert(dancers.length == 12);

            // TODO fail if the formations are wrong for the designator (currently we blindly apply) 

            let lineLen = dancersLineLen(dancers);
            if (designator == "v") {
                if (lineLen == 2)
                    return dancers.slice(4, 8);
                else if (lineLen == 6)
                    return dancers.slice(2, 4).concat(dancers.slice(8, 10));
                else
                    throw "Can't Determine Very Centers.";
            }
            if (designator == "c") {
                if (lineLen == 2)
                    return dancers.slice(2, 10);
                else if (lineLen == 4)
                    return [dancers[1], dancers[2], dancers[5], dancers[6], dancers[9], dancers[10]];
                else if (lineLen == 6)
                    return dancers.slice(1, 5).concat(dancers.slice(7, 11));
                else
                    throw "Can't Determine Centers.";
            }
            if (designator == "e") {
                if (lineLen == 2)
                    return [dancers[0], dancers[1], dancers[10], dancers[11]];
                else if (lineLen == 4)
                    return [dancers[0], dancers[3], dancers[4], dancers[7], dancers[8], dancers[11]];
                else if (lineLen == 6)
                    return [dancers[0], dancers[5], dancers[6], dancers[11]];
                else
                    throw "Can't Determine Ends.";
            }
            if (designator == "g" || designator == "b") {
                let wantBoy = (designator == "b");
                dancers = [];
                for (let dancer of floor.dancers) {
                    if (dancer.isBoy == wantBoy)
                        dancers.push(dancer)
                }
                return dancers;
            }
            throw "Unsupported Designator " + designator;
        }

        // when you have a heads or side designator, the dancers may not be
        // on the grid to start with.   Move them to the grid.
        function dancersMoveDancersToGrid(dancers, designator) {
            if (designator === "h" || designator === "s") {
                for (let dancer of dancers)
                    dancerScaleFacingCoordinate(dancer, Math.abs(1 / dancerGetFacingCoordinate(dancer)));
            }
        }

        // Validates the floor and returns an error message if the floor is bad.
        // returns undefined if the floor is valid.  
        function floorFindError(floor, designator, callFtn) {
            let dancers = floorGetDancers(floor);
            if (dancers.length != 12)
                return "Not 12 dancers";

            // TODO FIX: we turn off checking, we can do better. 
            if ((designator == "h" || designator == "s") && callFtn == doPromHalf) {
                return undefined;
            }

            // Can only have these lengths
            let lineLen = dancersLineLen(dancers);
            if (lineLen != 2 && lineLen != 4 && lineLen != 6 && lineLen != 12)
                return "Bad Line Length";

            let dancersFacingHeads = dancerIsFacingHeads(dancers[0]);
            for (let dancer of dancers) {
                if (dancerIsFacingHeads(dancer) != dancersFacingHeads)
                    return "T-Bone configuration for dancer";
                if (5 < Math.abs(dancer.gridX) || 5 < Math.abs(dancer.gridY))
                    return "Dancer outside Grid";
                if (Math.floor(dancer.gridX) != dancer.gridX || Math.floor(dancer.gridY) != dancer.gridY)
                    return "Dancer not on integral grid locations";
            }

            // two dancers can't have the same spot.  
            for (let i = 1; i < dancers.length; i++) {
                if (dancers[i - 1].gridX == dancers[i].gridX && dancers[i - 1].gridY == dancers[i].gridY)
                    return "Two dancers on the same spot";
            }

            // there is mirror symetry
            for (let i = 0; i < dancers.length / 2; i++) {
                if (dancers[i].gridX != -dancers[dancers.length - 1 - i].gridX)
                    return "Mirror fails for X for dancer " + i;
                if (dancers[i].gridY != -dancers[dancers.length - 1 - i].gridY)
                    return "Mirror fails for Y for dancer " + i;

                if (!dancersIsFacingOpposite(dancers[i], dancers[dancers.length - 1 - i]))
                    return "Mirror fails on Direction for dancer " + i;
            }

            if (lineLen == 2 && dancersLineLen(dancers, 2) == 4) {
                // It is a quarter tag [position].  dancer 0 hould be able to 
                // move forward 3 spaces and land on the dancer 3
                if (dancerGetFacingCoordinate(dancers[3]) - dancerGetFacingCoordinate(dancers[0]) != 3)
                    return "Bad Quarter Tag Formation end spacing";

                if (dancerGetCrossCoordinate(dancers[3]) != dancerGetCrossCoordinate(dancers[0]))
                    return "Bad Quarter Tag Formation left-right";

                dancers = floorGetDancers(floor, "c");  // just keep the centers
            }
            else if (lineLen == 4 && dancersLineLen(dancers, 4) == 2) {  // only valid for home position
                if (dancers[0].rotation != NORTH || dancers[4].rotation != EAST || dancers[5] != WEST)
                    return "Bad Home Position ";
                dancers = floorGetDancers(floor, "h");      // just keep the heads  
            }
            else {

                // We can tighten up where the dancers can be for the lines of 6 or columns case.   
                for (let dancer of dancers) {
                    if (lineLen == 6 && Math.abs(dancerGetFacingCoordinate(dancer)) != 1 ||
                        lineLen == 2 && Math.abs(dancerGetCrossCoordinate(dancer)) != 1)
                        return "Dancer off Grid";

                    // Symetry on the grid makes it unusual that dancers are on an axis 
                    // Only in odd line configure
                    if (dancerGetCrossCoordinate(dancer) == 0)
                        return "Dancers not symetric in side-to-side dimension";
                    if (dancerGetFacingCoordinate(dancer) == 0 && (12 / lineLen) % 2 != 1)
                        return "Dancers not symetric in front-back dimension";
                }
            }

            // Check The dancers are in a perfect rectangle on a grid 
            lineLen = dancersLineLen(dancers);
            let distBetweenLines = 0;        // means we did not init it.  
            let distBetweenDancers = Math.abs(dancerGetCrossCoordinate(dancers[1]) - dancerGetCrossCoordinate(dancers[0]));
            for (let lStart = 0; lStart < dancers.length; lStart += lineLen) {
                if (distBetweenLines == 0 && 0 < lStart)
                    distBetweenLines = Math.abs(dancerGetFacingCoordinate(dancers[lStart]) - dancerGetFacingCoordinate(dancers[0]));

                Math.abs(dancerGetFacingCoordinate(dancers[lStart]) - dancerGetFacingCoordinate(dancers[0]))

                for (let i = 1; i < lineLen; i++) {
                    let rlDist = Math.abs(dancerGetCrossCoordinate(dancers[lStart + i]) - dancerGetCrossCoordinate(dancers[lStart + i - 1]));
                    if (rlDist != distBetweenDancers)
                        return "Dancers not equally spaced left to right";

                    if (distBetweenLines != 0) {
                        let fbDist = Math.abs(dancerGetFacingCoordinate(dancers[lStart + i]) - dancerGetFacingCoordinate(dancers[lStart + i - lineLen]));
                        if (fbDist != distBetweenLines)
                            return "Dancers not equally spaced foward and back";
                    }
                }
            }

            return undefined;   // success (there is no error)
        }

        /*******************************************************************/
        /*                        SQUARE DANCE CALLS                       */

        /********************************************************************/

        function doHome(floor) {
            floorReset(floor);
        }

        /*******************************/
        /* Basic 1 calls */

        function doAllemandeLeft(floor, dancers) {
            if (!floor.isResolved)
                throw "Alemande Left on an unresolved square";
        }

        function doPassThru(floor, dancers) {
            for (let dancer of dancers) {
                if (floorIsFacingOut(floor, dancer))
                    throw "Dancers facing out can't pass thru";
                dancerMove(dancer, 2, 0, 0);
            }
        }

        function doTrade(floor, dancers) {
            for (let i = 0; i < dancers.length; i += 2) {
                trade(dancers[i], dancers[i + 1]);
            }
        }

        function doRightAndLeftThru(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                for (let beau of [box[0], box[3]])
                    dancerMove(beau, 2, 2, 2);
                for (let belle of [box[1], box[2]])
                    dancerMove(belle, 2, -2, 2);
            }
            floor.sweepCCW = 1;
        }

        function doStarThru(floor, dancers) {
            for (let dancer of dancers)
                dancerMove(dancer, 2, 0, dancer.isBoy ? -1 : 1);
        }

        function doLeadRight(floor, dancers) {
            for (let i = 0; i < dancers.length; i++) {
                let dancer = dancers[i];
                let beauFactor = (dancer.isBoy ? 1 : 0)           // TODO this should not be sex base.
                dancerMove(dancers[i], 2 * beauFactor, 2 * beauFactor, -1);
            }
        }

        function doSquareThru4(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                dancerMove(box[0], 0, 0, 1);
                dancerMove(box[1], 0, 0, -1);
                dancerMove(box[2], 0, 0, -1);
                dancerMove(box[3], 0, 0, 1);
            }
        }

        function doSquareThru2(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                dancerMove(box[0], 2, 2, -1);
                dancerMove(box[1], 2, -2, 1);
                dancerMove(box[2], 2, -2, 1);
                dancerMove(box[3], 2, 2, -1);
            }
        }

        function doVeerLeft(floor, dancers) {
            for (let dancer of dancers)
                dancerMove(dancer, 1, -2, 0);
        }

        function doCirculate(floor, dancers) {

            // figure out how far to walk forward
            let lineLen = dancersLineLen(dancers);
            let peopleInLine = dancers.length / lineLen;
            let delta = Math.abs(floor.maxFacing - floor.minFacing) / (peopleInLine - 1);

            for (let dancer of dancers) {
                if (floorIsFacingOut(floor, dancer)) {
                    if (dancerIsFacingHeads(dancer))
                        dancer.gridX = -dancer.gridX;         // flip the other side
                    else
                        dancer.gridY = -dancer.gridY;         // flip the other side
                    dancerMove(dancer, 0, 0, 2);        // flip direction
                }
                else
                    dancerMove(dancer, delta, 0, 0);
            }
        }

        function doChainDownTheLine(floor, dancers) {
            for (let line of dancersGetLinesOf4(dancers)) {
                for (let beau of [line[0], line[3]])
                    dancerMove(beau, 1, 2, -1);
                for (let belle of [line[1], line[2]])
                    dancerMove(belle, 1, 2, 1);
            }
            floor.sweepCCW = 1;
        }

        function doTurnBack(floor, dancers) {
            for (let dancer of dancers)
                dancerMove(dancer, 0, 0, 2);
        }

        function doHalfSashay(floor, dancers) {
            for (let i = 0; i < dancers.length; i += 2) {
                if (dancersIsFacingOpposite(dancers[i], dancers[i + 1]))
                    throw "Must be a couple (facing same direction)"
                swapPos(dancers[i], dancers[i + 1]);
            }
        }

        function doFaceIn(floor, dancers) {
            let lineLen = dancersLineLen(dancers);

            let needFaceEastWest;
            if (lineLen == 2) {    // column-like
                needFaceEastWest = dancerIsFacingHeads(dancers[0]);
            }
            else if (lineLen == 6) {
                needFaceEastWest = dancerIsFacingSides(dancers[0]);
            }
            else
                throw "Bad Formation for Face In";

            for (let i = 0; i < dancers.length; i++) {
                if (needFaceEastWest) {
                    if (dancers[i].gridX < 0)
                        dancers[i].rotation = 3;
                    else
                        dancers[i].rotation = 1;
                }
                else {
                    if (dancers[i].gridY < 0)
                        dancers[i].rotation = 0;
                    else
                        dancers[i].rotation = 2;
                }
            }
        }

        function doPromHalf(floor, dancers) {
            let isSides = dancerIsSides(dancers[0]);
            for (let i = 0; i < dancers.length / 2; i++) {
                if (dancerIsSides(dancers[i]) != isSides)
                    throw "Dancers must be all heads or all sides";
                swapPos(dancers[i], dancers[dancers.length - i - 1]);
                for (let dancer of [dancers[i], dancers[dancers.length - i - 1]])
                    dancerMove(dancer, 0, 0, 2);
            }
        }

        /*******************************/
        /* Basic 2 calls */

        function doExtend(floor, dancers) {
            let lineLen = dancersLineLen(dancers);
            let lineLen2 = dancersLineLen(dancers, 2);
            if (lineLen == 2 && lineLen2 == 4) {
                for (let i = 0; i < dancers.length; i++) {
                    dancerMove(dancers[i],
                        ((i <= 1 || 10 <= i) ? 1 : 2),                    // everyone but ends move forward
                        ((i == 0 || i == dancers.length - 1) ? -2 : 0), 0);  // only end on the left slides over 2
                }
            }
            else
                throw "Expected QuarterTag";
        }

        function doSweepAQuarter(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                if (floor.sweepCCW == 1) {
                    dancerMove(box[0], 0, 2, 1);
                    dancerMove(box[1], 2, 0, 1);
                    dancerMove(box[2], 2, 0, 1);
                    dancerMove(box[3], 0, 2, 1);
                }
                else if (floor.sweepCCW == -1) {
                    dancerMove(box[0], 2, 0, -1);
                    dancerMove(box[1], 0, -2, -1);
                    dancerMove(box[2], 0, -2, -1);
                    dancerMove(box[3], 2, 0, -1);
                }
                else
                    throw "Sweep 1/4 requires previous call to have 2 dancer flow.";
            }
        }

        function doFlutterWheel(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                dancerMove(box[0], 2, 2, 2);
                dancerMove(box[3], 2, 2, 2);
            }
            floor.sweepCCW = -1;
        }

        function doReverseFlutterWheel(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                dancerMove(box[1], 2, -2, 2);
                dancerMove(box[2], 2, -2, 2);
            }
            floor.sweepCCW = 1;
        }

        function doPassTheOcean(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                for (let beau of [box[0], box[3]])
                    dancerMove(beau, 4, 1, -1);
                for (let belle of [box[1], box[2]])
                    dancerMove(belle, 2, -1, 1);
            }
        }

        function doSwingThru(floor, dancers) {
            // TODO swing thru is not correct for left handed waves (it does a left swing thru)

            // Allow the facing couple ocean wave rule TODO do this more uniformly.   This is a hack
            let lineLen = dancersLineLen(dancers);
            if (lineLen == 2 && dancers.length == 12) {
                doStepToAWave(floor, dancers);
                return doSwingThru(floor, floorGetDancers(floor));
            }

            // check if the formation  is valid
            for (let i = 1; i < dancers.length; i++) {
                if (!dancersIsFacingOpposite(dancers[i], dancers[i - 1]))
                    throw "Need to have alternating dancers" + (lineLen == 4 ? " (need to call stw?)" : "");
            }

            if (lineLen == 4) {
                for (let start = 0; start < dancers.length; start += lineLen) {
                    trade(dancers[start], dancers[start + 1]);
                    trade(dancers[start + 2], dancers[start + 3]);

                    // centers trade (note that we have to use the ORIGINAL indexes
                    // to fetch people now in the center
                    trade(dancers[start], dancers[start + 3]);
                }
            }
            else if (lineLen == 6) {
                for (let start = 0; start < dancers.length; start += lineLen) {
                    trade(dancers[start], dancers[start + 1]);
                    trade(dancers[start + 2], dancers[start + 3]);
                    trade(dancers[start + 4], dancers[start + 5]);

                    // centers trade (note that we have to use the ORIGINAL indexes
                    // to fetch people now in the center
                    trade(dancers[start], dancers[start + 3]);
                    trade(dancers[start + 2], dancers[start + 5]);
                }
            }
            else
                throw "Expected ocean waves.";
        }

        function doBoysRun(floor, dancers) {
            for (let i = 0; i < 12; i += 2) {
                if (dancers[i].isBoy == dancers[i + 1].isBoy)
                    throw "Same sex next to each other";

                swapPos(dancers[i], dancers[i + 1]);
                if (dancers[i].isBoy)
                    dancerMove(dancers[i], 0, 0, 2);
                else
                    dancerMove(dancers[i + 1], 0, 0, 2);
            }
        }

        function doGirlsRun(floor, dancers) {
            for (let i = 0; i < 12; i += 2) {
                if (dancers[i].isBoy == dancers[i + 1].isBoy)
                    throw "Same sex next to each other";

                swapPos(dancers[i], dancers[i + 1]);
                if (dancers[i].isBoy)
                    dancerMove(dancers[i + 1], 0, 0, 2);
                else
                    dancerMove(dancers[i], 0, 0, 2);
            }
        }

        function doStepToAWave(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                dancerMove(box[0], 1, -2, 0);
                dancerMove(box[1], 1, 0, 0);
                dancerMove(box[2], 1, 0, 0);
                dancerMove(box[3], 1, -2, 0);
            }
        }

        function doTradeBy(floor, dancers) {
            // Needed to avoid center boxes working 
            if (!dancerFacingAwayFromCenter(dancers[0]) || !(dancers.length == 12 || dancers.length == 8))
                throw "Not a Trade-By formation";

            trade(dancers[0], dancers[1]);
            // middle people pass thru
            for (let i = 2; i < dancers.length - 2; i++)
                dancerMove(dancers[i], 2, 0, 0);
            trade(dancers[dancers.length - 2], dancers[dancers.length - 1]);
        }

        function doBendTheLine(floor, dancers) {
            let lineLen = dancersLineLen(dancers);
            if (lineLen == 4) {
                for (let line of dancersGetLinesOf4(dancers)) {
                    // this is -1 for left handed waves, 1 for right handed
                    let left = (line[0].rotation == 0 || line[0].rotation == 3) ? 1 : -1;

                    for (let end of [line[0], line[3]])
                        dancerMove(end, 1, 2 * left, -left);
                    for (let center of [line[1], line[2]])
                        dancerMove(center, -1, 0, -left);
                }
                floor.sweepCCW = -1; // only for 2 faced, but that is the only kind possible here  TODO handle left handed
            }
            else if (lineLen == 6 && floorIsFacingOut(floor, dancers[0])) {

                // group them into groups of 3, in a box, box3 is the box of the groups of 3
                // boxes are in the order
                //  2 3 
                //  0 1
                for (let box3 = 0; box3 < 4; box3++) {
                    // we iterate over the group from the center of the line (indexBase) out (idxDir)
                    let idxDir = box3 % 2 * 2 - 1                          // -1 on  0,2        1 on  1,3
                    let idxBase = 2 + 6 * Math.floor(box3 / 2) + box3 % 2    // yields 0,1,2,3  -> 2, 3, 8, 9 (center box)

                    let rotation = (1 <= box3 && box3 <= 2) ? -1 : 1;   //  1 on 0,3        -1 on  1,2
                    let dir = -rotation;                                 // -1 on 0,3         1 on  1,2
                    for (let i = 0; i < 3; i++)
                        dancerMove(dancers[idxBase + i * idxDir], 2 * i, 2 * i * dir, rotation);
                }
            }
            else
                throw "Formation wrong for bend the line.";
        }

        function doTagTheLine(floor, dancers) {
            let lineLen = dancersLineLen(dancers);
            // We don't implement tag the line for lines of 4 although we could.
            // it would mean adding lines of 3 as a legal configuration, and it does
            // not seem worth it right now
            if (lineLen == 6) {
                let facingSides = dancerIsFacingSides(dancers[0]);
                for (let i = 0; i < dancers.length; i++) {
                    let quadrant = Math.floor(i / 3);
                    let rotation = (quadrant % 2 == 0) ? 3 : 1;
                    if (facingSides)
                        --rotation;
                    dancers[i].rotation = rotation;         // Face in to the center  
                    dancerMove(dancers[i], 6, 0, 0);        // move 6 positions in the new direction
                }
            }
            else
                throw "Formation wrong for tag the line.";
        }


        function doTouchAQuarter(floor, dancers) {
            for (let dancer of dancers) {
                dancerMove(dancer, 2, 0, -1);
            }
        }

        function doStretchFerrisWheel(floor, dancers) {
            _doWheelFamily(floor, dancers, 5);
        }
        function doFerrisWheel(floor, dancers) {
            _doWheelFamily(floor, dancers, 3);
        }
        function doWheelAndDeal(floor, dancers) {
            _doWheelFamily(floor, dancers, 1);
        }

        // Handles Wheel+Deal (stretch=1), Ferris Wheel(stretch=3) and Stretch Ferris Wheel (stretch=5)
        function _doWheelFamily(floor, dancers, stretch) {
            let lines = dancersGetLinesOf4(dancers)
            for (let i = 0; i < lines.length; i++) {
                let line = lines[i];
                let dancerStretch = stretch;
                if (stretch == 5 && i == 1)        // For stretch ferris wheel, the middle group is not stretched.
                    dancerStretch = 3;

                for (let beau of [line[0], line[3]]) {
                    if (floorIsFacingOut(floor, beau))
                        dancerMove(beau, 1, 4, 2);
                    else
                        dancerMove(beau, dancerStretch, 4, 2);
                }
                for (let belle of [line[1], line[2]]) {
                    if (floorIsFacingOut(floor, belle))
                        dancerMove(belle, 1, 0, 2);
                    else
                        dancerMove(belle, dancerStretch, 0, 2);
                }
            }
            floor.sweepCCW = -1;        // only for centers
        }

        function doZoom(floor, dancers) {
            // these are arranged in twos up the central column
            for (let i = 0; i < dancers.length; i++) {
                if (4 <= i && i < 8)                  // Very Centers roll back
                    dancerMove(dancers[i], -4, 0, 0);
                else
                    dancerMove(dancers[i], 2, 0, 0);  // Otherwise move forward
            }
        }

        function doTriplePassThru(floor, dancers) {
            // these are arranged in twos up the central column
            for (let dancer of dancers)
                dancerMove(dancer, 6, 0, 0);
        }

        function doCloverleaf(floor, dancers) {
            // group them into groups of 3, in a box, box3 is the box of the groups of 3
            // boxes are in the order
            //  2 3 
            //  0 1
            for (let box3 = 0; box3 < 4; box3++) {
                // we iterate over the group from the center of the line (indexBase) out (idxDir)
                let idxDir = 2 * Math.floor(box3 / 2) - 1;         // -1 for 0, 1    1 for 1, 2
                let idxBase = 4 + box3;                                // iterates over the very center box
                let rotation = (box3 == 0 || box3 == 3) ? 1 : -1
                let dir = rotation;
                for (let i = 0; i < 3; i++)
                    dancerMove(dancers[idxBase + 2 * idxDir * i], -2 * i, (4 - 2 * i) * dir, rotation);
            }
        }

        function doBoxTheGnat(floor, dancers) {
            for (let dancer of dancers) {
                if (floorIsFacingOut(floor, dancer))
                    throw "Dancers facing out can't box the gnat";
                dancerMove(dancer, 2, 0, 2);
            }
        }

        /*******************************/
        /* MainStream calls */

        function doHinge(floor, dancers) {
            let lineLen = dancersLineLen(dancers);

            // we have a line of 6 we need to expand it out before doing the hinge to make space
            if (lineLen == 6) {
                for (let dancer of dancers)
                    dancerScaleFacingCoordinate(dancer, 2);
            }

            for (let dancer of floor.dancers)
                dancerMove(dancer, 1, 1, -1);

            // if we started with 3 lines of 4 we end up with two lines of 6, contract it down
            if (lineLen == 4) {
                for (let dancer of dancers)
                    dancerScaleFacingCoordinate(dancer, 0.5);
            }
        }

        function doPassToTheCenter(floor, dancers) {
            // this is needed to avoid allowing on lines facing in
            let lineLen = dancersLineLen(dancers);
            if (lineLen != 2 || !(dancers.length == 12 || dancers.length == 8))
                throw "Formation Wrong for Pass To The Center";

            // everyone passes through
            for (let dancer of dancers)
                dancerMove(dancer, 2, 0, 0);

            // The ends need to partner trade 
            // remember you have to use the STARTING index 
            trade(dancers[2], dancers[3]);
            trade(dancers[dancers.length - 4], dancers[dancers.length - 3]);
        }

        function doRecycle(floor, dancers) {
            for (let line of dancersGetLinesOf4(dancers)) {
                for (let beau of [line[0], line[3]])
                    dancerMove(beau, 1, 4, 2)
                for (let belle of [line[1], line[2]])
                    dancerMove(belle, -1, 0, 0)
            }
            floor.sweepCCW = -1;
        }

        function doHalfTag(floor, dancers) {
            for (let line of dancersGetLinesOf4(dancers)) {
                for (let beau of [line[0], line[3]])
                    dancerMove(beau, 1, 2, -1)
                for (let belle of [line[1], line[2]])
                    dancerMove(belle, 1, 2, -1)
            }
        }

        function doDixieStyle(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                for (let beau of [box[0], box[3]])
                    dancerMove(beau, 0, 1, 1);
                for (let belle of [box[1], box[2]])
                    dancerMove(belle, 4, -1, 1);
            }
        }

        function doWalkAndDodge(floor, dancers) {
            for (let box of dancersGetBoxes(dancers)) {
                for (let beau of [box[0], box[3]])
                    dancerMove(beau, 2, 0, 0);
                for (let belle of [box[1], box[2]])
                    dancerMove(belle, 0, 2, 0);
            }
        }

        /********************************************************************/
        // END OF SQUARE DANCE CALLS
        /********************************************************************/

        /********************************************************************/
        // GUI Drawing support

        // puts the orgin in the center and makes y grow up not down
        // Thus it acts like how you would set up x,y in math class. 
        function setOriginInCenter(canvas, canvasContext) {
            let centerX = canvas.width / 2;
            let centerY = canvas.height / 2;

            canvasContext.translate(centerX, centerY);
            canvasContext.scale(1, -1);
        }

        // the main method for drawing the floor.
        function floorDraw(floor, canvas) {
            const canvasContext = canvas.getContext('2d');

            canvasContext.clearRect(0, 0, canvas.width, canvas.height);

            // number of pixels between dancer position grid
            // for width == 500 -> gridSize == 40
            const gridSize = canvas.width / 12.5;

            // Draw a grid of dots
            setOriginInCenter(canvas, canvasContext);
            canvasContext.fillStyle = "black";
            for (let x = -6; x <= 6; x++) {
                for (let y = -6; y <= 6; y++) {
                    canvasContext.beginPath();
                    canvasContext.arc(x * gridSize, y * gridSize, 2, 0, 2 * Math.PI);
                    canvasContext.fill();
                }
            }
            // draw a cross on the origin
            canvasContext.beginPath();
            canvasContext.moveTo(gridSize, 0);
            canvasContext.lineTo(-gridSize, 0);
            canvasContext.moveTo(0, gridSize);
            canvasContext.lineTo(0, -gridSize);
            canvasContext.stroke();

            if (floor === undefined)
                return;

            canvasContext.setTransform(1, 0, 0, 1, 0, 0);

            // draw Dancers
            for (let dancer of floor.dancers) {
                dancerDraw(dancer, canvas, canvasContext, gridSize)
            }

            canvasContext.setTransform(1, 0, 0, 1, 0, 0);
        }

        function dancerDraw(dancer, canvas, canvasContext, gridSize) {
            setOriginInCenter(canvas, canvasContext);

            canvasContext.translate(dancer.gridX * gridSize, dancer.gridY * gridSize);

            canvasContext.rotate(Math.PI / 2.0 * dancer.rotation)
            canvasContext.fillStyle = COLORS[dancer.number - 1];

            // draw boy or girl
            if (dancer.isBoy)
                canvasContext.fillRect(-0.35 * gridSize, -0.35 * gridSize, 0.7 * gridSize, 0.7 * gridSize);
            else {
                canvasContext.beginPath();
                canvasContext.arc(0, 0, 0.4 * gridSize, 0, 2 * Math.PI);
                canvasContext.fill();
            }
            // draw bulge
            canvasContext.beginPath();
            canvasContext.arc(0, 0.38 * gridSize, 0.2 * gridSize, 0, 2 * Math.PI);
            canvasContext.fill();

            // draw the couple number
            canvasContext.rotate(-Math.PI / 2.0 * dancer.rotation)
            canvasContext.scale(1, -1);
            canvasContext.font = (gridSize / 2) + "px Arial";
            canvasContext.fillStyle = "black";
            canvasContext.fillText(dancer.number, -gridSize * 0.15, gridSize * 0.2);

            canvasContext.setTransform(1, 0, 0, 1, 0, 0);
        }

        /********************************************************************/
        // logic for handling GUI callbacks 

        // called when textbox changes (someone hits enter or paste in it)
        function textBoxOnChange(event) {
            console.log("GUI callback textBoxOnChange", event);
            let textBox = event.currentTarget;
            console.assert(textBox.nodeName === "INPUT");   // it is a textBox. 
            let call = textBox.value;
            textBox.value = "";
            onCommand(call);
        }

        // called when you click on list item in g_callHistory
        function callHistoryOnClick(event) {
            console.log("GUI callback callHistoryOnClick", event);
            let listItem = event.currentTarget;
            console.assert(listItem.nodeName === "LI");      // it is a list item  
            let idx = listItem["data-index"];
            console.assert(idx !== undefined);
            g_callListSelectedItemIdx = idx;
            syncGUIToModel()
        }

        /*****************************/
        function onKeyDown(event) {
            console.log("GUI callback callHistoryOnClick", event);
            if (0 < g_callHistory.length) {
                if (event.key == "ArrowUp")
                    g_callListSelectedItemIdx = Math.max(0, g_callListSelectedItemIdx - 1);
                else if (event.key == "ArrowDown")
                    g_callListSelectedItemIdx = Math.min(g_callHistory.length - 1, g_callListSelectedItemIdx + 1);
                else if (event.key == "ArrowRight") // End key
                    g_callListSelectedItemIdx = g_callHistory.length - 1;
                else if (event.key == "ArrowLeft") // Home key
                    g_callListSelectedItemIdx = 0;
            }
            syncGUIToModel();
        }

        // called from either the GUI buttons or by user typing a command.  
        function onCommand(command) {
            console.log("onCommand", command);

            while (true) {
                let match = command.match(/^(([hsbgcev]) )?(\S+)\s*(.*)$/);
                if (!match)
                    break;

                let designator = match[2];
                let call = match[3];
                command = match[4];
                let fullCall = call;
                if (designator)
                    fullCall = designator + " " + call;

                if (checkForCommand(call))
                    continue;

                // We always get the last end floor, we don't look at the selected position.  
                let startFloor = getEndFloor(g_callHistory, g_callHistory.length - 1);
                let floor = floorDeepCopy(startFloor);

                // transform the floor with a square dance call.  
                if (!doCall(floor, call, designator, fullCall))
                    break;

                // remember the results in the call History.  
                g_callHistory.push({ startFloor: startFloor, call: fullCall, endFloor: floor });
            }
            // always move the selection point to the end of the list. 
            g_callListSelectedItemIdx = g_callHistory.length - 1;
            syncGUIToModel();
        }

        function checkForCommand(command) {

            // This is just to make testing easy.   Users don't use the command.  
            if (command == "tst") {
                doTest();
                return true;
            }
            if (command == "reset") {
                g_callHistory = [];
                g_messageSpan.innerHTML = "Reset complete.";
                return true
            }
            if (command == "undo") {
                if (0 < g_callHistory.length) {
                    let prev = g_callHistory.pop();
                    g_messageSpan.innerHTML = "Undid: <b>" + prev.call + "</b>";

                    if (0 < g_callHistory.length) {
                        let prevHistory = g_callHistory[g_callHistory.length - 1];
                        g_messageSpan.innerHTML += " last call now: <b>" + prevHistory.call + "</b>";
                    }
                }
                else
                    logError("Nothing to undo.");
                return true;
            }
            return false;
        }

        // Given 'call' (like rtl, sq4 ...) and a designator (e.g. h s c e v ...) 
        // actually update the floor (and the GUI) to execute the call.  
        function doCall(floor, call, designator, fullCall) {
            // The full call includes the designator, we use it when showing the call to the user.  
            console.log("Doing call", fullCall);

            // most calls do not have flow, so reset it here to create a default
            // don't reset it for sweep a quarter itself since we need that 
            // flow information to actually do the call and don't want to destroy it.   
            if (call != "saq")
                floor.sweepCCW = 0;                // 0 means no sweep  

            try {
                // Fetch the javaScript function that does the call
                let callFtn = CALL_TO_FTN[call.toLowerCase()];
                if (!callFtn)
                    throw "Unknown Call '" + call + "'";

                // parse the desginators to determine what dancers actually move.  
                let dancers = floorGetDancers(floor, designator);
                dancersMoveDancersToGrid(dancers, designator);

                // and call the function. 
                callFtn(floor, dancers);

                // See if the call did something illegal.
                let formationError = floorFindError(floor, designator, callFtn);
                if (formationError) {
                    console.log("Validating call failed, formation error: " + formationError);
                    syncGUIToModel();   // this is only here to make debugging easier you can see then error formation 
                    throw "Error: Bad formation for '" + call + "'" + "'";
                }
                floor.isResolved = floorIsResolved(floor);
            } catch (err) {
                logError("Error Executing Call: " + err);
                return false;
            }

            // update other GUI state after a successful model update
            g_messageSpan.innerHTML = "Finished Call: " + fullCall;
            return true;
        }

        function logError(message) {
            beep();
            g_messageSpan.innerHTML = "<b>" + message + "</b>";
        }

        function getEndFloor(callHistory, curIndex) {
            console.assert(-1 <= curIndex && curIndex < callHistory.length);

            if (curIndex < 0)       // length is 0.  
                return floorReset();
            return callHistory[curIndex].endFloor;
        }

        function getStartFloor(callHistory, curIndex) {
            console.assert(-1 <= curIndex && curIndex < callHistory.length);

            if (curIndex < 0)       // length is 0.  
                return undefined
            return callHistory[curIndex].startFloor;
        }

        // called when we want to make sure that the GUI represents the model (after we changed the model)
        function syncGUIToModel() {
            let endFloor = getEndFloor(g_callHistory, g_callListSelectedItemIdx);

            // If we ar resolved turn on the label that says so.  
            g_resolvedsSpan.style.visibility = endFloor.isResolved ? "visible" : "hidden";

            floorDraw(endFloor, g_mainCanvas);

            let prevFloor = getStartFloor(g_callHistory, g_callListSelectedItemIdx);
            floorDraw(prevFloor, g_prevCanvas);

            // Update the history listg_callListSelecteItem
            g_callListOrderedList.replaceChildren();
            for (let i = 0; i < g_callHistory.length; i++) {
                let li = document.createElement("li");
                li["data-index"] = i;                   // remember where I am in the list 
                li.innerText = g_callHistory[i].call;
                li.addEventListener("click", callHistoryOnClick);
                g_callListOrderedList.appendChild(li);
            }
            if (0 <= g_callListSelectedItemIdx)
                g_callListOrderedList.children[g_callListSelectedItemIdx].style.backgroundColor = "#4498E1";
        }

        // used to initialize the CALL_TO_FTN table. 
        function getCallFtns() {
            let ret = {};
            ret["home"] = doHome;
            ret["al"] = doAllemandeLeft;
            ret["pt"] = doPassThru;
            ret["p1/2"] = doPromHalf;
            ret["p12"] = doPromHalf;
            ret["srt"] = doStarThru;
            ret["sl"] = doStarThru;
            ret["rlt"] = doRightAndLeftThru;
            ret["vl"] = doVeerLeft;
            ret["sq4"] = doSquareThru4;
            ret["sq2"] = doSquareThru2;
            ret["lr"] = doLeadRight;
            ret["ptd"] = doTrade;
            ret["st"] = doSwingThru;
            ret["ex"] = doExtend;
            ret["btl"] = doBendTheLine;
            ret["ttl"] = doTagTheLine;
            ret["tb"] = doTradeBy;
            ret["stw"] = doStepToAWave;
            ret["br"] = doBoysRun;
            ret["gr"] = doGirlsRun;
            ret["sb"] = doTrade;;
            ret["td"] = doTrade;;
            ret["sq3"] = doTrade;;
            ret["hs"] = doHalfSashay;
            ret["utb"] = doTurnBack;
            ret["cdtl"] = doChainDownTheLine;
            ret["pto"] = doPassTheOcean;
            ret["saq"] = doSweepAQuarter;
            ret["fl"] = doFlutterWheel;
            ret["rfl"] = doReverseFlutterWheel;
            ret["tq"] = doTouchAQuarter;
            ret["circ"] = doCirculate;
            ret["hinge"] = doHinge;
            ret["whd"] = doWheelAndDeal;
            ret["zoom"] = doZoom;
            ret["fw"] = doFerrisWheel;
            ret["sfw"] = doStretchFerrisWheel;
            ret["ptc"] = doPassToTheCenter;
            ret["rec"] = doRecycle;
            ret["ht"] = doHalfTag;
            ret["fi"] = doFaceIn;
            ret["dx"] = doDixieStyle;
            ret["wad"] = doWalkAndDodge;
            ret["cl"] = doCloverleaf;
            ret["bg"] = doBoxTheGnat;
            ret["tpt"] = doTriplePassThru;
            return ret;
        }

        /********************************************************************/
        // support for sound (beeps)

        function beep() { tone(50, 440); }

        function tone(duration, frequency) {
            if (audioCtx === undefined)
                audioCtx = new window.AudioContext;
            let oscillator = audioCtx.createOscillator();
            let gainNode = audioCtx.createGain();

            oscillator.connect(gainNode);
            gainNode.connect(audioCtx.destination);

            oscillator.frequency.value = frequency;
            // oscillator.type = "sine"; 

            oscillator.start();
            setTimeout(function () { oscillator.stop() }, duration);
        };
        let audioCtx;

        /********************************************************************/
        /********************************************************************/
        // TESTING    Called by the 'tst' command to allow quick unit testing
        function doTest() {
            // just run a long sequence that resolves and uses every call.   
            onCommand(
                "reset h pto ex st br cdtl pt btl tq circ circ circ br sq4 btl srt pt " +
                "tb srt dx e circ gr btl pto hinge td hinge rec saq srt vl sfw v pt c pt sl pt hs utb fl " +
                "rfl srt pt tb pt tb fl sq3 ptd vl sfw zoom zoom tpt cl zoom fi srt cl v pt c pt pt tb pt tb " +
                "pt tb tq wad ptd rfl srt ptc c sq3 srt pto st br ht sb br srt stw st br whd " +
                "lr ptd rlt saq vl fw c pt rlt hs bg rlt " +
                "srt ttl cl fi srt pt tb pt tb srt tq circ circ circ br rlt pt tb rlt vl sfw v sq3 c ptc v pt c pt rlt pt tb"
            );

            let endFloor = g_callHistory[g_callHistory.length - 1].endFloor;
            if (!endFloor.isResolved) {
                logError("TestError: test did not resolve the square");
                return;
            }

            if (!g_messageSpan.innerHTML.match(/error/i))
                g_messageSpan.innerHTML = "<b>" + "Successful Testing.  Square should be resolved (corner boxes)." + "</b>";
        }
    </script>
</body>

</html>