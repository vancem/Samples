<!doctype html>

<head>
    <style>
        /********************************************************************/
        .window {
            box-sizing: border-box;
            height: 100vh;
            /* layout of children */
            display: flex;
            flex-direction: column;
        }

        .textWindow {
            flex-grow: 1;
            border: solid black 1px;
            margin: 1px;
        }

        #cursor {
            border-left-width: 2px;
            margin-left: -2px;
            position: relative;
            left: 2px;
            border-left-style: solid;
            border-left-color: black;
            animation: cursorAnimation 1s infinite
        }

        @keyframes cursorAnimation {
            0% {
                border-left-color: black;
            }

            50% {
                border-left-color: white;
            }

            100% {
                border-left-color: black;
            }
        }
    </style>
</head>
<html>

<body style="margin:0;">
    <!-- by default margin=8 which I don't want because I want vh=100 to be the whole screen -->
    <div class="window">
        <div>
            <input type="file" id="openFileInput" onchange="doOpenFileDialogClose(event)" style="display:none">
            <button onclick="document.getElementById('openFileInput').click()">Open</button>
            Find: <input type="text" onchange="doFindTextInputChange(event)"></input>
            <button onClick="doFindNextButton(event)">Next</button>
            Status: <div id="statusDiv"></div>
        </div>
        <div id="textEditor" tabindex="1" autofocus class="textWindow"></div>
    </div>
    <!-- *********************************************************************** -->
    <script>
    </script>
    <script>
        "use strict";

        class TextEditor {
            // instance fields
            #cursor; #charWidth; #editorWindow;

            constructor(parentWindow) {
                this.#editorWindow = parentWindow;
                this.#editorWindow.editor = this;
                this.#editorWindow.onkeydown = TextEditor.#onKeyDown;
                this.#editorWindow.onpaste = TextEditor.#onPaste;
                this.#editorWindow.onclick = TextEditor.#onMouseClick;
                this.#editorWindow.style["font-family"] = "'Courier New', Courier, monospace";
                this.#editorWindow.style["font-size"] = "12px";
                this.#editorWindow.style["padding"] = "3px";
                this.#editorWindow.style["white-space"] = "pre";
                this.#editorWindow.style["overflow"] = "hidden";

                const cursorLine = document.createElement("div");
                this.#editorWindow.appendChild(cursorLine);

                this.#cursor = document.createElement("span");
                this.#cursor.id = "cursor";
                cursorLine.appendChild(this.#cursor);

                this.#charWidth = this.#computeCharWidth();
            }

            // simple helper that computes the character with for a given font
            // Note for this to make sense the font has to be fixed width.  
            #computeCharWidth() {
                const style = window.getComputedStyle(this.#editorWindow);
                const canvas = document.createElement("canvas");
                const context = canvas.getContext("2d");
                context.font = style.font;
                return context.measureText("M").width;  // we can use any character since it is fix width, pick a 'big' one
            }

            addString(str) {
                assert(typeof (str) == "string");
                for (let i = 0; i < str.length; i++)
                    this.#addChar(str[i]);
            }

            #addChar(ch) {
                assert(ch.length == 1);
                if (ch == "\n")
                    this.#addNewLineChar();
                else if (" " <= ch && ch <= "~" || ch == "\t") {
                    if (ch == " " || ch == "\t")
                        ch = "\u00A0"; // no break space char. 
                    this.#cursor.before(document.createTextNode(ch));
                }
                else if (ch != "\r")
                    console.log("Skipping illegal char 0x" + ch.charCodeAt(0).toString(16));
            }

            #addNewLineChar() {
                // Make the new line 
                const newLine = document.createElement("div");
                const cursorLine = this.#cursor.parentNode;
                cursorLine.after(newLine);

                // Move the cursor and everything after it to the new line.  
                let toMove = this.#cursor;
                while (toMove != null) {
                    const nextCharChild = toMove.nextSibling;
                    toMove.remove();
                    newLine.appendChild(toMove);
                    toMove = nextCharChild;
                }

                // Leave behind a space on empty lines to avoid collapse.   
                if (cursorLine.firstChild == null)
                    cursorLine.appendChild(document.createTextNode("\u00A0"));
            }

            deleteChar() {
                const prevChar = this.#cursor.previousSibling;
                if (prevChar != null)
                    prevChar.remove();
            }

            moveLeft() {
                const prevChar = this.#cursor.previousSibling;
                if (prevChar != null) {
                    prevChar.remove();
                    this.#cursor.after(prevChar);
                }
            }
            moveRight() {
                const nextChar = this.#cursor.nextSibling;
                if (nextChar != null) {
                    nextChar.remove();
                    this.#cursor.before(nextChar);
                }
            }

            moveUp() {
                const prevLine = this.#cursor.parentNode.previousSibling;
                if (prevLine != null) {
                    const cursorIdx = childIndex(this.#cursor);
                    this.#cursor.remove();
                    insertChildAt(prevLine, this.#cursor, cursorIdx);
                }
            }

            moveDown() {
                const nextLine = this.#cursor.parentNode.nextSibling;
                if (nextLine != null) {
                    const cursorIdx = childIndex(this.#cursor);
                    this.#cursor.remove();
                    insertChildAt(nextLine, this.#cursor, cursorIdx);
                }
            }

            /************************  GUI callback methods ******************/
            static #onMouseClick(event) {
                console.log("onMouseClick: ", event);
                const line = event.target;
                if (event.target == null)
                    return;
                const editor = event.currentTarget.editor;  // get editor associated with this DOM elememnt
                if (editor == null)
                    return;
                if (line.parentNode != editor.#editorWindow)
                    return;
                const charPos = event.offsetX / editor.#charWidth;
                const idx = Math.round(charPos);
                if (line.childNodes.length < idx)
                    return;
                editor.#cursor.remove();
                insertChildAt(line, editor.#cursor, idx);
            }

            static #onPaste(event) {
                console.log("onPaste: ", event);
                const text = event.clipboardData.getData("text");
                if (!text)
                    return;
                const editor = event.currentTarget.editor;  // get editor associated with this DOM elememnt
                if (editor == null)
                    return;
                editor.addString(text);
            }

            static #onKeyDown(event) {
                console.log("onKeyDown: ", event);
                if (event.ctrlKey)
                    return;
                if (event.altKey)
                    return;
                if (event.metaKey)
                    return;

                const editor = event.currentTarget.editor;  // get editor associated with this DOM elememnt
                if (editor == null)
                    return;
                if (event.key.length == 1) {
                    if (" " <= event.key && event.key <= "~")
                        editor.#addChar(event.key);
                }
                else if ("Enter" == event.key)
                    editor.#addNewLineChar();
                else if ("Backspace" == event.key || "Delete" == event.key)
                    editor.deleteChar();
                else if ("ArrowLeft" == event.key)
                    editor.moveLeft();
                else if ("ArrowRight" == event.key)
                    editor.moveRight();
                else if ("ArrowUp" == event.key)
                    editor.moveUp();
                else if ("ArrowDown" == event.key)
                    editor.moveDown();
                else
                    console.log("Unknonwn key: ", event);
            }
        }

        /***********************************************************************/
        const newLine = "\n".codePointAt(0); // \n as a integer
        const bufferSize = 1024 * 16;
        class BigFile {
            // private fields
            #file; #utf8Decoder; #utf8Encoder;
            #positionOfBuffer; #offsetInBuffer; #offsetInBufferEnd; #buffer;

            constructor(file) {
                assert(file.size && file.slice);    // should at least look like a File type
                this.#file = file;
                this.#utf8Decoder = new TextDecoder("utf-8");
                this.#positionOfBuffer = 0;
                this.#offsetInBuffer = 0;
                this.#offsetInBufferEnd = 0;
            }

            // returns the size of the file
            get size() { return this.#file.size; }
            // position in the file (from zero to size())
            get position() { return this.#positionOfBuffer + this.#offsetInBuffer; }
            // returns the (short) name do the file (files may not have a full path)
            get name() { return this.#file.name; }
            // returns true if the cursor is at the end of file (readLine will return "")
            get endOfFile() { return this.size <= this.postion; }

            // Returns the next line in the file, returns the empty string on end of file. 
            // It will only read 'maxByte' (not characters), so you can use that to limit
            // the size of the line returned.    
            async readLine(maxBytes = Infinity) {
                let retStr = undefined;
                let curPos = this.#offsetInBuffer;
                let endPos = this.#offsetInBufferEnd;   // cached for speed
                let buffer = this.#buffer;              // cached for speed
                let maxPos = curPos + maxBytes;
                while (curPos < maxPos) {
                    if (endPos <= curPos) {
                        // This code is not hot, it only happens ever bufferSize chars. 
                        if (this.#offsetInBuffer < curPos) {
                            retStr ||= "";  // If not set yet, set it to the empty string.      
                            retStr += this.#utf8Decoder.decode(buffer.slice(this.#offsetInBuffer, curPos));
                        }
                        const newPositionOfBuffer = this.#positionOfBuffer + curPos;
                        if (this.size <= newPositionOfBuffer)  // Hit end of file
                            break;
                        maxPos -= curPos - this.#offsetInBuffer;
                        await this.#fill(newPositionOfBuffer);
                        curPos = this.#offsetInBuffer;
                        endPos = this.#offsetInBufferEnd;
                        buffer = this.#buffer;
                    }
                    // Note it increments the position past the newline before breaking out of the loop. 
                    if (buffer[curPos++] === newLine)
                        break;
                }
                const chunkStr = this.#utf8Decoder.decode(buffer.slice(this.#offsetInBuffer, curPos));
                this.#offsetInBuffer = curPos;
                return (retStr === undefined) ? chunkStr : retStr + chunkStr; // concatinate if necessary.  
            }

            // scans backwards in the file one line (it basically undoes a readLine)
            async seekLineBackwards() {
                let origPos = this.#offsetInBuffer;
                let curPos = origPos;
                let buffer = this.#buffer;            // cached for speed
                while (true) {
                    // have we fallen off the front of the buffer? 
                    if (curPos === 0) {
                        if (this.#positionOfBuffer === 0)  // Hit start of file
                            break;
                        await this.#fill(this.#positionOfBuffer - bufferSize);
                        curPos += bufferSize;
                        origPos += bufferSize;
                        buffer = this.#buffer;
                    }
                    // Note it increments the position past the newline before breaking out of the loop. 
                    // We also have to find the newline further than the neighboring location so we read 
                    // the newline before that.   
                    if (buffer[--curPos] === newLine && 1 < (origPos - curPos)) {
                        curPos++;  // This could be off the end of the buffer, but that is OK, as the next read will fill it. 
                        break;
                    }
                }
                this.#offsetInBuffer = curPos;
            }

            async search(searchStr, searchEndPos = this.size) {
                assert(0 < searchStr.length);
                if (searchStr.length == 0)
                    return true;   // should never happen, but 

                this.#utf8Encoder ||= new TextEncoder();
                const searchBytes = this.#utf8Encoder.encode(searchStr);
                if (this.size < searchEndPos)
                    searchEndPos = this.size;

                let searchIdx = 0;                      // how much of searchBytes matches so far.  
                let curPos = this.#offsetInBuffer;
                let endPos = this.#offsetInBufferEnd;   // cached for speed
                let buffer = this.#buffer;            // cached for speed
                while (true) {
                    if (endPos <= curPos) {
                        // This code is not hot, it only happens ever bufferSize chars.  
                        const newPositionOfBuffer = this.#positionOfBuffer + curPos;
                        if (searchEndPos <= newPositionOfBuffer) { // Hit end of search region
                            this.#offsetInBuffer = curPos;
                            return false;
                        }
                        await this.#fill(newPositionOfBuffer);
                        curPos = this.#offsetInBuffer;
                        endPos = this.#offsetInBufferEnd;
                        buffer = this.#buffer;
                    }
                    // Note it increments the position past the newline before breaking out of the loop. 
                    if (buffer[curPos++] === searchBytes[searchIdx]) {
                        searchIdx++;
                        if (searchBytes.length <= searchIdx) {
                            this.#offsetInBuffer = curPos;
                            await this.seek(this.position - searchBytes.length); // We want to be at the start of the search string. 
                            return true;
                        }
                    }
                    else if (0 < searchIdx) {
                        console.log(`RESETTING after finding ${searchIdx} chars`);
                        // Start over one byte further on (curPos has been incremented at this point)
                        if (searchIdx <= curPos)
                            curPos -= searchIdx;
                        else {  // this is the case where the string spans a buffer boundary.  
                            await this.seek(this.#positionOfBuffer + curPos - searchIdx);
                            curPos = this.#offsetInBuffer;
                            endPos = this.#offsetInBufferEnd;
                        }
                        searchIdx = 0;
                        console.log(`AFTER RESETTING pos = ${curPos}`);
                        console.log(`AFTER RESETTING ***>${this.#utf8Decoder.decode(this.#buffer.slice(curPos, curPos+40))}`);
                    }
                }
            }

            // seeks to the given position.  If position is negative, it seeks from the end of the file. 
            async seek(position) {
                if (position < 0)
                    position = this.size + position;
                position = Math.max(0, Math.min(position, this.size))

                const offset = position - this.#positionOfBuffer;
                if (0 <= offset && offset < bufferSize) {
                    this.#offsetInBuffer = offset;
                    return;
                }

                // Round position to bufferSize, and fill the buffer.  
                const newPositionOfBuffer = Math.floor(position / bufferSize) * bufferSize;
                await this.#fill(newPositionOfBuffer);
                assert(this.#offsetInBuffer < bufferSize);
                assert(this.#positionOfBuffer % bufferSize == 0);   // we read in bufferSize chunks aways.  
                return this.position;
            }

            // Fill the buffer with 'bufferSize' bytes (if we don't hit EOF) starting at file offset 'filePos'
            async #fill(filePos) {
                assert(filePos % bufferSize == 0);   // we read in bufferSize chunks aways.  
                this.#positionOfBuffer = filePos;
                const bufferBlob = this.#file.slice(this.#positionOfBuffer, this.#positionOfBuffer + bufferSize);
                const bufferArrayBuffer = await bufferBlob.arrayBuffer();
                this.#buffer = new Uint8Array(bufferArrayBuffer);
                this.#offsetInBuffer = 0;
                this.#offsetInBufferEnd = this.#buffer.length;
                // TODO remove after debugging.  
                this.DEBUGBytes = this.#utf8Decoder.decode(this.#buffer.slice(0, 80));
            }
        }

        /************************  utility functions ******************/
        function insertChildAt(node, newChild, newChildIdx) {
            const children = node.childNodes;
            if (newChildIdx < children.length)
                node.insertBefore(newChild, children[newChildIdx]);
            else
                node.appendChild(newChild);
        }

        // returns the number of children before 'child'
        function childIndex(child) {
            let ret = 0;
            while (true) {
                child = child.previousSibling;
                if (child == null)
                    break;
                ret++;
            }
            return ret;
        }

        // Asserts that something is true (here so we can turn it off easily);
        function assert(condition) {
            console.assert(condition);
        }

        /*************************************************************************/
        // main program
        let myEditor = new TextEditor(document.getElementById("textEditor"));

        async function doOpenFileDialogClose(event) {
            console.log("doFindTextboxChange", event);
            const fileList = event.target.files;
            if (fileList.length == 0)
                return;     // user canceled
            const file = fileList[0];
            console.log("opening file ", file);

            const bigFile = new BigFile(file);
            for (let i = 0; i < 20; i++) {
                const line = await bigFile.readLine(1000);
                console.log(`Got line ${i} pos: ${bigFile.position} len: ${line.length} = ${line}`);
                myEditor.addString(line);
            }

            myEditor.addString("\n*********************************    ...   ************************************\n\n");

            await bigFile.seekLineBackwards();
            console.log(`Backing up a line pos:  ${bigFile.position}`);
            await bigFile.seekLineBackwards();
            console.log(`Backing up a line pos:  ${bigFile.position}`);
            let line = await bigFile.readLine(1000);
            console.log(`READ line pos: ${bigFile.position} len: ${line.length} = ${line}`);
            line = await bigFile.readLine(1000);
            console.log(`READ line pos: ${bigFile.position} len: ${line.length} = ${line}`);

            console.log("***************************************************************");
            console.log("Showing the end of the file. ")
            await bigFile.seek(bigFile.size - 2000);
            await bigFile.readLine()  // Don't display the clipped line
            for (let i = 0; i < 50; i++) {
                line = await bigFile.readLine(1000);
                if (line.length == 0)
                    break;
                console.log(`Got line: ${1} pos: ${bigFile.position} len: ${line.length} = ${line}`);
                myEditor.addString(line);
            }
            console.log("***************************************************************");
            console.log("Searching for ath="); // HarddiskVolume3
            await bigFile.seek(0);
            line = await bigFile.readLine(1000);
            console.log(`First Line ${line}`);
            const searchResult = await bigFile.search("ath=", 4000);
            console.log(`Got search result ${searchResult}`);
            const data = await bigFile.readLine(1000);
            console.log(`Got search data ***>${data}`);
        }

        function doFindTextInputChange(event) {
            const textBoxStr = event.target.value;
            console.log("doFindTextboxChange " + textBoxStr, event);
        }

        function doFindNextButton(event) {
            console.log("doFindNextButton", event);
        }

    </script>
</body>

</html>